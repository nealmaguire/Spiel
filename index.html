<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Wavelength – Spiel (Fix: Ränder, 3-4-5-4-3, Punkte korrekt)</title>
<style>
  :root{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;--accent:#2563eb}
  body{margin:0;padding:0;display:flex;flex-direction:column;min-height:100vh;background:#f6f7fb;color:#111}
  header{padding:12px;background:var(--accent);color:white;text-align:center}
  main{flex:1;padding:12px;max-width:920px;margin:0 auto;box-sizing:border-box}
  .card{background:white;border-radius:10px;padding:12px;box-shadow:0 6px 18px rgba(16,24,40,0.08);margin-bottom:12px}
  input[type=text]{width:100%;padding:8px;margin-top:6px;border-radius:6px;border:1px solid #ddd}
  button{padding:10px 12px;border-radius:8px;border:0;background:var(--accent);color:white;font-weight:600;margin-top:8px}
  button.secondary{background:#4b5563}
  .small{font-size:0.9rem;color:#555}
  .row{display:flex;gap:8px;align-items:center}
  .canvas-wrap{width:100%;height:420px;border-radius:8px;background:linear-gradient(180deg,#fff,#f3f4f6);touch-action:none;display:flex;align-items:center;justify-content:center;overflow:hidden}
  canvas{max-width:100%;height:100%;border-radius:8px;display:block}
  .palette{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
  .pal-btn{width:36px;height:36px;border-radius:6px;border:2px solid transparent;cursor:pointer}
  .pal-btn.disabled{opacity:0.35;cursor:default;transform:none;pointer-events:none}
  .pal-btn.selected{outline:3px solid rgba(0,0,0,0.06);transform:translateY(-2px)}
  .player-swatch{width:18px;height:18px;border-radius:4px;margin-right:8px;border:1px solid #ddd;display:inline-block;vertical-align:middle}
  #playerList button{display:block;width:100%;text-align:left;padding:10px;margin-top:6px;border-radius:8px;border:1px solid #eee;background:#fafafa;position:relative;color:black}
  #playerList button.done{opacity:0.45}
  #playerList button.current{box-shadow:0 0 0 3px rgba(0,0,0,0.06);animation:pulse 1.2s infinite}
  @keyframes pulse{0%{box-shadow:0 0 0 0 rgba(0,0,0,0.06)}70%{box-shadow:0 0 0 8px rgba(0,0,0,0)}100%{box-shadow:0 0 0 0 rgba(0,0,0,0)}}
  .muted{color:#888}
  .notice{padding:8px;border-radius:8px;background:#fff7c2;color:#775a00;margin-top:8px}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  .confirm-btn{background:#10b981}
  .name-input{flex:1}
  .muted-small{color:#999;font-size:0.9rem}
  .center{display:flex;align-items:center;justify-content:center;flex-direction:column}
  .score-row{display:flex;justify-content:space-between;padding:6px 0;border-bottom:1px solid #f0f0f0}
  table.round-table{width:100%;border-collapse:collapse;margin-top:8px}
  table.round-table th, table.round-table td{padding:6px;text-align:left;border-bottom:1px solid #eee}
</style>
</head>
<body>
<header><h1>Wavelength – Spiel</h1></header>
<main>
  <div class="card" id="setupCard">
    <h2>Spieler anlegen</h2>
    <div class="small">Gib Namen ein und wähle eine Farbe (jede Farbe nur einmal verfügbar).</div>

    <div style="display:flex;gap:8px;margin-top:8px">
      <input id="playerName" class="name-input" placeholder="Name eingeben" />
      <button id="addPlayer">Hinzufügen</button>
    </div>

    <div class="small" style="margin-top:10px">Farbauswahl (10 Farben):</div>
    <div class="palette" id="palette"></div>

    <div id="playersArea" style="margin-top:10px"></div>

    <hr>
    <div class="muted-small">Die Kategorien werden automatisch aus <code>kategorien.csv</code> geladen (je Zeile 1 Kategorie).</div>

    <div style="margin-top:12px">
      <button id="startGame">Spiel starten</button>
    </div>
  </div>

  <div class="card" id="gameCard" style="display:none">
    <h2>Runde</h2>
    <div id="roundInfo" class="small muted"></div>
    <div style="margin-top:8px"><div id="categoryText" class="small" style="margin-top:8px"></div></div>
    <hr>

    <div id="masterArea" style="display:none">
      <div class="small">Spielmacher: <strong id="masterName"></strong></div>
      <div class="canvas-wrap" style="margin-top:8px"><canvas id="canvasMaster"></canvas></div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="showTargetBtn">Ziel kurz anzeigen</button>
        <button id="hideTargetBtn" style="display:none">Ziel verbergen</button>
        <button id="masterDoneBtn">Fertig — Hand weitergeben</button>
      </div>
      <div id="masterHint" class="notice" style="display:none">Zeige das Ziel nur kurz dem Spielmacher, danach verbergen.</div>
    </div>

    <div id="guessArea" style="display:none;margin-top:12px">
      <div class="small">Gib das Handy weiter. Jeder Spieler (außer Spielmacher) wählt seinen Namen, zieht den Pfeil entlang des Halbkreises und bestätigt.</div>
      <div id="playerList" style="margin-top:8px"></div>
      <div class="canvas-wrap" style="margin-top:8px"><canvas id="canvasGuess"></canvas></div>
      <div class="controls" style="margin-top:8px">
        <button id="confirmBtn" class="confirm-btn" style="display:none">Bestätigen</button>
        <button id="cancelBtn" class="secondary">Abbrechen</button>
      </div>
      <div id="selectNotice" class="small muted" style="margin-top:6px"></div>
    </div>

    <div id="resultsArea" style="display:none;margin-top:12px">
      <h3>Ergebnis</h3>
      <div id="postRoundNotice" class="notice" style="display:none"></div>
      <div style="margin-top:8px" id="postRoundControls"></div>
      <div id="revealCanvasWrap" class="center" style="margin-top:12px; width:100%"></div>

      <div id="roundSummary" style="margin-top:12px"></div>

      <div id="scores" style="margin-top:8px"></div>
      <div style="margin-top:8px"><button id="newRoundBtn">Nächste Runde</button></div>
    </div>
  </div>
</main>
<footer class="small muted">Speichere <code>kategorien.csv</code> in deinem Repo-Root, eine Kategorie pro Zeile.</footer>

<script>
// ---------------- CONFIG ----------------
const SEGMENT_FULL_DEG = 5.0;          // voller Keil in Grad (z.B. 5°)
const SEGMENT_HALF_DEG = SEGMENT_FULL_DEG / 2.0;
const ARROW_OUTER_OFFSET = 36;         // Abstand Basis-Pfeil von äußerem Bogen (px)
const ARROW_BASE_ANGLE_WIDTH = 0.048;  // radians -> Breite des Pfeil-Basiswinkels
// ----------------------------------------

const el = id => document.getElementById(id);
const PALETTE = ['#ef4444','#f97316','#f59e0b','#eab308','#84cc16','#10b981','#06b6d4','#3b82f6','#8b5cf6','#ec4899'];
let selectedPaletteColor = PALETTE[0];
let players = []; // {name,color,status}
let categories = ["Schlechter Film - Guter Film","Heiß - Kalt","Mutig - Ängstlich"];
let masterIndex = 0;
let targetAngle = null; // 0..180
let confirmedGuesses = {}; // name -> angle
let currentPicker = null;
let tempAngle = null;
let totalScores = {}; // kumuliert
let roundPointsAdded = false;

let canvasMaster, canvasGuess, mctx, gctx;

// helper colors
function hexToRgb(hex){ const h=hex.replace('#',''); const n=parseInt(h,16); return [(n>>16)&255,(n>>8)&255,n&255]; }
function rgba(hex,a=1){ const [r,g,b]=hexToRgb(hex); return `rgba(${r},${g},${b},${a})`; }

// load CSV categories
async function loadCategoriesCSV(){
  try{
    const resp = await fetch('kategorien.csv');
    if(!resp.ok) return;
    const txt = await resp.text();
    const lines = txt.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    if(lines.length) categories = categories.concat(lines);
  }catch(e){ console.log('CSV load error', e); }
}

// Palette & players UI
function renderPalette(){
  const wrap = el('palette'); wrap.innerHTML='';
  PALETTE.forEach(c=>{
    const used = players.some(p=>p.color === c);
    const b = document.createElement('button');
    b.className = 'pal-btn' + (used ? ' disabled' : '');
    b.style.background = c;
    if(c === selectedPaletteColor && !used) b.classList.add('selected');
    b.title = used ? 'Bereits gewählt' : 'Wähle diese Farbe';
    if(!used){
      b.addEventListener('click', ()=>{ selectedPaletteColor = c; document.querySelectorAll('.pal-btn').forEach(x=>x.classList.remove('selected')); b.classList.add('selected'); });
    }
    wrap.appendChild(b);
  });
  if(players.some(p=>p.color === selectedPaletteColor)){
    const free = PALETTE.find(c => !players.some(p=>p.color===c));
    if(free) selectedPaletteColor = free;
  }
}

function renderPlayersArea(){
  const area = el('playersArea'); area.innerHTML='';
  if(players.length === 0){ area.innerHTML = '<div class="small muted">Keine Spieler</div>'; return; }
  players.forEach((p,i)=>{
    const div = document.createElement('div'); div.className='row'; div.style.marginTop='6px';
    div.innerHTML = `<span class="player-swatch" style="background:${p.color}"></span>
      <div style="flex:1;color:black">${i+1}. <strong>${p.name}</strong> <span style="color:#888">(${p.status})</span></div>
      <div><button data-i="${i}" class="removeBtn">Entf.</button></div>`;
    area.appendChild(div);
  });
  document.querySelectorAll('.removeBtn').forEach(b=>b.addEventListener('click', e=>{
    const i = +e.currentTarget.dataset.i; const removed = players.splice(i,1)[0];
    // free color automatically via renderPalette
    renderPlayersArea(); renderPalette();
  }));
}

el('addPlayer').addEventListener('click', ()=>{
  const name = el('playerName').value.trim();
  if(!name) return;
  if(players.find(p=>p.name === name)){ alert('Name bereits vorhanden'); return; }
  if(players.some(p=>p.color === selectedPaletteColor)){ alert('Diese Farbe ist bereits vergeben. Wähle eine andere.'); return; }
  players.push({name, color: selectedPaletteColor, status: 'pending'});
  el('playerName').value = '';
  renderPlayersArea(); renderPalette();
});

// start game
el('startGame').addEventListener('click', async ()=>{
  if(players.length < 2){ alert('Mindestens 2 Spieler erforderlich'); return; }
  await loadCategoriesCSV();
  totalScores = {}; players.forEach(p => totalScores[p.name] = 0);
  el('setupCard').style.display='none'; el('gameCard').style.display='block';
  masterIndex = Math.floor(Math.random()*players.length);
  startRound();
});

function startRound(){
  confirmedGuesses = {}; currentPicker = null; tempAngle = null; roundPointsAdded = false;
  players.forEach(p=>p.status='pending'); players[masterIndex].status='master';
  targetAngle = Math.floor(Math.random()*(178-2+1))+2;
  el('categoryText').textContent = categories[Math.floor(Math.random()*categories.length)];
  el('roundInfo').textContent = `Spielmacher: ${players[masterIndex].name}`;
  el('masterName').textContent = players[masterIndex].name;
  el('masterArea').style.display='block'; el('guessArea').style.display='none'; el('resultsArea').style.display='none';
  el('masterHint').style.display='none'; el('showTargetBtn').style.display='inline-block'; el('hideTargetBtn').style.display='none';
  renderMaster(false); renderGuess(); renderPlayerList(); renderTotals();
}

// canvas setup & metrics
function setupCanvases(){
  canvasMaster = el('canvasMaster'); canvasGuess = el('canvasGuess');
  mctx = canvasMaster.getContext('2d'); gctx = canvasGuess.getContext('2d');
  function resize(c,ctx,h=380){
    const dpi = window.devicePixelRatio || 1;
    const parent = c.parentElement; const w = Math.max(320, parent.clientWidth - 12);
    c.style.width = w + 'px'; c.style.height = h + 'px';
    c.width = Math.floor(w * dpi); c.height = Math.floor(h * dpi);
    ctx.setTransform(dpi,0,0,dpi,0,0);
  }
  resize(canvasMaster,mctx,380); resize(canvasGuess,gctx,380);
  window.addEventListener('resize', ()=>{ resize(canvasMaster,mctx,380); resize(canvasGuess,gctx,380); renderMaster(false); renderGuess(); });
}
function metrics(ctx){
  const dpi = window.devicePixelRatio || 1;
  const w = ctx.canvas.width / dpi; const h = ctx.canvas.height / dpi; const cx = w/2;
  const cy = h - 8; const r = Math.min(w/2 - 8, h - 12);
  return {w,h,cx,cy,r};
}

// draw base semicircle
function drawBase(ctx){
  const m = metrics(ctx);
  ctx.clearRect(0,0,ctx.canvas.width/(window.devicePixelRatio||1), ctx.canvas.height/(window.devicePixelRatio||1));
  ctx.beginPath(); ctx.moveTo(m.cx - m.r, m.cy); ctx.arc(m.cx, m.cy, m.r, Math.PI, 2*Math.PI, false); ctx.closePath();
  ctx.fillStyle = '#fff'; ctx.fill(); ctx.lineWidth = 1.6; ctx.strokeStyle = '#c7cfe0'; ctx.stroke();
}

// helper: build centers array (left->right) and labels/colors
function getSegmentCentersAndMeta(centerAngle){
  const full = SEGMENT_FULL_DEG;
  const centers = [centerAngle - 2*full, centerAngle - full, centerAngle, centerAngle + full, centerAngle + 2*full];
  // clamp centers to 0..180 (if edge, still keep sorted left->right)
  const centersClamped = centers.map(c => Math.max(0, Math.min(180, c)));
  // labels & colors in order left->right: 3,4,5,4,3
  const labels = [3,4,5,4,3];
  const colors = ['#16a34a','#f59e0b','#ef4444','#f59e0b','#16a34a'];
  return {centers: centersClamped, labels, colors};
}

// draw segments equal size and correct order 3,4,5,4,3
function drawTargetSegmentsInside(ctx, centerAngle){
  const m = metrics(ctx);
  const outer = m.r - 6; const inner = Math.max(m.r - 100, m.r * 0.40);
  const halfDeg = SEGMENT_HALF_DEG;
  const {centers, labels, colors} = getSegmentCentersAndMeta(centerAngle);
  for(let i=0;i<centers.length;i++){
    const angleDeg = centers[i];
    const color = colors[i];
    const label = labels[i];
    const centerRad = Math.PI + (angleDeg * Math.PI/180);
    const halfRad = halfDeg * Math.PI/180;
    const start = centerRad - halfRad;
    const end = centerRad + halfRad;
    ctx.beginPath();
    ctx.moveTo(m.cx + inner*Math.cos(start), m.cy + inner*Math.sin(start));
    ctx.lineTo(m.cx + outer*Math.cos(start), m.cy + outer*Math.sin(start));
    ctx.arc(m.cx, m.cy, outer, start, end, false);
    ctx.lineTo(m.cx + inner*Math.cos(end), m.cy + inner*Math.sin(end));
    ctx.arc(m.cx, m.cy, inner, end, start, true);
    ctx.closePath();
    ctx.fillStyle = color; ctx.globalAlpha = 0.95; ctx.fill(); ctx.globalAlpha = 1;
    ctx.lineWidth = 0.8; ctx.strokeStyle = 'rgba(0,0,0,0.06)'; ctx.stroke();
    const mid = centerRad;
    const lx = m.cx + (inner + (outer-inner)/2) * Math.cos(mid);
    const ly = m.cy + (inner + (outer-inner)/2) * Math.sin(mid);
    ctx.fillStyle = '#111'; ctx.font = 'bold 12px sans-serif'; ctx.fillText(String(label), lx-6, ly+4);
  }
}

// draw arrow: outside -> tip on outer arc; clamp base radius so not clipped at edges
function drawArrow(ctx, angle, color, label, highlighted=false){
  const m = metrics(ctx);
  const ang = Math.PI + (angle * Math.PI/180);
  const outerR = m.r; // tip on outer border
  let baseOuterR = m.r + ARROW_OUTER_OFFSET; // ideal

  // clamp baseOuterR so base points stay within canvas + margin
  const margin = 6;
  const tryClamp = (rCandidate) => {
    let r = rCandidate;
    for(let attempt=0; attempt<30; attempt++){
      const leftX  = m.cx + r * Math.cos(ang + ARROW_BASE_ANGLE_WIDTH);
      const leftY  = m.cy + r * Math.sin(ang + ARROW_BASE_ANGLE_WIDTH);
      const rightX = m.cx + r * Math.cos(ang - ARROW_BASE_ANGLE_WIDTH);
      const rightY = m.cy + r * Math.sin(ang - ARROW_BASE_ANGLE_WIDTH);
      const okLeft = leftX >= margin && leftX <= (m.w - margin) && leftY >= margin && leftY <= (m.h - margin);
      const okRight = rightX >= margin && rightX <= (m.w - margin) && rightY >= margin && rightY <= (m.h - margin);
      if(okLeft && okRight) break;
      r -= 6;
      if(r <= m.r + 2) { r = m.r + 2; break; }
    }
    return r;
  };
  baseOuterR = tryClamp(baseOuterR);

  // tip slightly inset to avoid overlap stroke
  const tipX = m.cx + (outerR - 1) * Math.cos(ang), tipY = m.cy + (outerR - 1) * Math.sin(ang);
  const leftX  = m.cx + baseOuterR * Math.cos(ang + ARROW_BASE_ANGLE_WIDTH);
  const leftY  = m.cy + baseOuterR * Math.sin(ang + ARROW_BASE_ANGLE_WIDTH);
  const rightX = m.cx + baseOuterR * Math.cos(ang - ARROW_BASE_ANGLE_WIDTH);
  const rightY = m.cy + baseOuterR * Math.sin(ang - ARROW_BASE_ANGLE_WIDTH);

  ctx.beginPath(); ctx.moveTo(leftX,leftY); ctx.lineTo(tipX,tipY); ctx.lineTo(rightX,rightY); ctx.closePath();
  ctx.fillStyle = rgba(color,1); ctx.fill();
  if(highlighted){ ctx.lineWidth=2; ctx.strokeStyle='rgba(0,0,0,0.12)'; ctx.stroke(); }

  // label aside - clamp inside canvas
  const labelR = baseOuterR + 8;
  let lx = m.cx + labelR * Math.cos(ang);
  let ly = m.cy + labelR * Math.sin(ang);
  const labelX = Math.min(Math.max(lx + 8, 6), m.w - 80);
  ctx.fillStyle = '#000'; ctx.font = highlighted ? 'bold 13px sans-serif' : '12px sans-serif';
  ctx.fillText(label, labelX, ly + 4);
}

// render master view
let masterShow = false;
function renderMaster(force=false){
  drawBase(mctx);
  if(force || masterShow) drawTargetSegmentsInside(mctx, targetAngle);
  if(!force && !masterShow){
    const mm = metrics(mctx);
    mctx.fillStyle='rgba(0,0,0,0.03)';
    mctx.fillRect(0,0,mctx.canvas.width/(window.devicePixelRatio||1), mctx.canvas.height/(window.devicePixelRatio||1));
    mctx.fillStyle='#444'; mctx.font='14px sans-serif';
    mctx.fillText('Ziel ist versteckt. Nur Spielmacher darf es sehen.', 12, 20);
  }
}

// render guess canvas (do not draw confirmed players)
function renderGuess(){
  drawBase(gctx);
  if(currentPicker && tempAngle !== null){
    const p = players.find(pp=>pp.name===currentPicker);
    if(p) drawArrow(gctx, tempAngle, p.color, p.name, true);
  }
}

// player list UI
function renderPlayerList(){
  const cont = el('playerList'); cont.innerHTML='';
  players.forEach(p=>{
    if(p.status === 'master') return;
    const btn = document.createElement('button');
    btn.textContent = p.name; btn.style.color='black';
    btn.classList.remove('done','current');
    if(p.status === 'done') btn.classList.add('done');
    if(p.status === 'current') btn.classList.add('current');
    const sw = document.createElement('span'); sw.className='player-swatch'; sw.style.background = p.color;
    if(p.status === 'done') sw.style.opacity = 0.35;
    btn.prepend(sw);
    btn.addEventListener('click', ()=>{
      if(p.status === 'done'){ alert('Dieser Spieler hat bereits bestätigt.'); return; }
      players.forEach(pp=>{ if(pp.status === 'current') pp.status='pending'; });
      p.status = 'current'; currentPicker = p.name; tempAngle = null;
      el('selectNotice').textContent = `Markiere jetzt: ${p.name}`;
      el('confirmBtn').style.display = 'inline-block';
      renderPlayerList(); renderGuess();
    });
    cont.appendChild(btn);
  });
}

// robust canvas->angle
function canvasToAngle(clientX, clientY, ctx){
  const rect = ctx.canvas.getBoundingClientRect();
  const x = clientX - rect.left; const y = clientY - rect.top;
  const m = metrics(ctx);
  if(y > m.cy + 60) return null;
  let nx = (x - m.cx) / m.r; nx = Math.max(-1, Math.min(1, nx));
  const arcRad = Math.acos(nx);
  let angleB = 180 - (arcRad * 180 / Math.PI);
  const dxA = x - m.cx; const dyA = m.cy - y;
  let phi = Math.atan2(dyA, dxA); let phiDeg = phi * 180 / Math.PI;
  let angleA = 180 - phiDeg; angleA = (angleA + 360) % 360;
  if(angleA < 0 || angleA > 180) angleA = null;
  function projDist(angleDeg){
    if(angleDeg === null) return 1e9;
    const ang = Math.PI + (angleDeg * Math.PI/180);
    const px = m.cx + m.r * Math.cos(ang); const py = m.cy + m.r * Math.sin(ang);
    return Math.hypot(px - x, py - y);
  }
  const dA = projDist(angleA), dB = projDist(angleB);
  const chosen = (dA <= dB) ? angleA : angleB;
  const dx = x - m.cx, dy = y - m.cy; const distToCenter = Math.hypot(dx, dy);
  if(distToCenter > m.r + 80) return null;
  if(distToCenter < m.r * 0.2) return null;
  return (chosen === null) ? null : Math.round(chosen);
}

// bind drag
function bindGuessDrag(){
  let dragging = false;
  canvasGuess.addEventListener('pointerdown', e=>{
    if(!currentPicker) return;
    dragging = true; canvasGuess.setPointerCapture(e.pointerId);
    const a = canvasToAngle(e.clientX, e.clientY, gctx);
    if(a === null){ el('selectNotice').textContent = 'Nur entlang des Halbkreises wählen.'; setTimeout(()=>el('selectNotice').textContent='',900); return; }
    tempAngle = a; renderGuess();
  });
  canvasGuess.addEventListener('pointermove', e=>{
    if(!dragging) return;
    const a = canvasToAngle(e.clientX, e.clientY, gctx);
    if(a === null) return;
    tempAngle = a; renderGuess();
  });
  canvasGuess.addEventListener('pointerup', e=>{
    dragging = false; canvasGuess.releasePointerCapture(e.pointerId);
  });
}

// Confirm / Cancel
el('confirmBtn').addEventListener('click', ()=>{
  if(!currentPicker){ alert('Wähle zuerst deinen Namen'); return; }
  if(tempAngle === null){ alert('Ziehe zuerst den Pfeil'); return; }
  confirmedGuesses[currentPicker] = tempAngle;
  const p = players.find(pp=>pp.name === currentPicker); if(p) p.status = 'done';
  currentPicker = null; tempAngle = null;
  el('confirmBtn').style.display = 'none';
  el('selectNotice').textContent = 'Markierung gespeichert.'; setTimeout(()=>el('selectNotice').textContent = '', 900);
  renderPlayerList(); renderGuess();

  const remaining = players.filter(pp=>pp.status !== 'done' && pp.status !== 'master');
  if(remaining.length === 0){
    el('guessArea').style.display='none'; el('resultsArea').style.display='block';
    el('postRoundNotice').style.display='block'; el('postRoundNotice').textContent = 'Alle Spieler haben gewählt. Bitte gebe das Handy an den Spielmacher zurück.';
    const ctrl = el('postRoundControls'); ctrl.innerHTML = '';
    const btn = document.createElement('button'); btn.textContent = 'Ergebnis anzeigen (Spielmacher)';
    btn.addEventListener('click', ()=>{
      renderReveal(true);
      if(!roundPointsAdded){ addRoundPointsToTotals(); roundPointsAdded = true; }
      renderScoresAndRound();
      btn.disabled = true; el('postRoundNotice').style.display = 'none'; el('revealCanvasWrap').scrollIntoView({behavior:'smooth', block:'center'});
    });
    ctrl.appendChild(btn);
  }
});

el('cancelBtn').addEventListener('click', ()=>{
  if(currentPicker){
    const p = players.find(pp=>pp.name === currentPicker); if(p) p.status='pending';
    currentPicker = null; tempAngle = null;
    el('confirmBtn').style.display = 'none'; el('selectNotice').textContent = '';
    renderPlayerList(); renderGuess();
  }
});

// master controls
el('showTargetBtn').addEventListener('click', ()=>{ masterShow = true; el('masterHint').style.display='block'; el('showTargetBtn').style.display='none'; el('hideTargetBtn').style.display='inline-block'; renderMaster(true); });
el('hideTargetBtn').addEventListener('click', ()=>{ masterShow = false; el('masterHint').style.display='none'; el('hideTargetBtn').style.display='none'; el('showTargetBtn').style.display='inline-block'; renderMaster(false); });
el('masterDoneBtn').addEventListener('click', ()=>{ el('masterArea').style.display='none'; el('guessArea').style.display='block'; renderGuess(); renderPlayerList(); bindGuessDrag(); });

// reveal & scoring
function renderReveal(showTarget){
  const wrap = el('revealCanvasWrap'); const w = wrap.clientWidth || Math.max(320, document.documentElement.clientWidth - 24); const h = 340;
  const c = document.createElement('canvas'); const dpi = window.devicePixelRatio || 1;
  c.width = Math.floor(w * dpi); c.height = Math.floor(h * dpi); c.style.width = w + 'px'; c.style.height = h + 'px';
  const ctx = c.getContext('2d'); ctx.setTransform(dpi,0,0,dpi,0,0);
  drawBase(ctx);
  // draw all confirmed arrows
  Object.entries(confirmedGuesses).forEach(([name,ang])=>{ const p = players.find(pp=>pp.name === name); if(p) drawArrow(ctx, ang, p.color, name, false); });
  if(showTarget) drawTargetSegmentsInside(ctx, targetAngle);
  wrap.innerHTML=''; wrap.appendChild(c);
}

// Compute round points using segment centers and halfDeg: assign 3/4/5/4/3 or 0
function computeRoundPoints(){
  const roundPts = {};
  const {centers, labels} = getSegmentCentersAndMeta(targetAngle);
  // ensure everyone (except master) in table with default 0
  players.forEach(p => { if(p.name !== players[masterIndex].name) roundPts[p.name] = 0; });
  Object.entries(confirmedGuesses).forEach(([name,ang])=>{
    // find first segment where |ang - center| <= halfDeg
    let assigned = 0;
    for(let i=0;i<centers.length;i++){
      const c = centers[i];
      if(Math.abs(ang - c) <= SEGMENT_HALF_DEG + 0.0001){ assigned = labels[i]; break; }
    }
    roundPts[name] = assigned;
  });
  return roundPts;
}

function addRoundPointsToTotals(){
  const roundPts = computeRoundPoints();
  Object.entries(roundPts).forEach(([name,pts])=>{
    if(totalScores[name] === undefined) totalScores[name] = 0;
    totalScores[name] += pts;
  });
  renderTotals();
}

// Show round points + totals after reveal
function renderScoresAndRound(){
  const roundPts = computeRoundPoints();
  const roundDiv = el('roundSummary'); roundDiv.innerHTML = '';
  const tbl = document.createElement('table'); tbl.className = 'round-table';
  const thead = document.createElement('thead'); thead.innerHTML = `<tr><th>Spieler</th><th>Rundenpunkte</th><th>Gesamtpunkte</th></tr>`; tbl.appendChild(thead);
  const tbody = document.createElement('tbody');
  players.forEach(p => {
    if(p.name === players[masterIndex].name) return; // optional: exclude master from scoring rows
    const rp = roundPtsFor(p.name:=undefined) // placeholder to avoid linter confusion
  });
  // Build tbody properly
  Object.keys(totalScores).forEach(name=>{
    if(name === players[masterIndex].name) return;
    const p = players.find(pp=>pp.name===name) || {color:'#111'};
    const rp = (computeRoundPoints()[name] || 0);
    const tot = totalScores[name] || 0;
    const tr = document.createElement('tr');
    tr.innerHTML = `<td style="color:${p.color}"><strong>${name}</strong></td><td>${rp}</td><td>${tot}</td>`;
    tbody.appendChild(tr);
  });
  tbl.appendChild(tbody); roundDiv.appendChild(tbl);
  renderTotals();
}

// render totals area
function renderTotals(){
  const node = el('scores'); node.innerHTML = '';
  const arr = Object.entries(totalScores).sort((a,b)=>b[1]-a[1]);
  arr.forEach(([name,pts])=>{
    const p = players.find(pp=>pp.name === name) || {color:'#111'};
    const sw = `<span style="display:inline-block;width:12px;height:12px;background:${p.color};border-radius:3px;margin-right:8px"></span>`;
    const div = document.createElement('div'); div.className='score-row';
    div.innerHTML = `<div>${sw}${name}</div><div><strong>${pts} P</strong></div>`;
    node.appendChild(div);
  });
  const md = document.createElement('div'); md.className='small muted'; md.style.marginTop='6px'; md.textContent = 'Gesamtpunkte'; node.appendChild(md);
}

// next round
el('newRoundBtn').addEventListener('click', ()=>{
  masterIndex = (masterIndex + 1) % players.length;
  startRound();
});

// init
function init(){ renderPalette(); setupCanvases(); renderPlayersArea(); }
init();

</script>
</body>
</html>
