<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wavelength - Spiel (Palette + sichtbare Segmente)</title>
  <style>
    :root{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;--accent:#2563eb;}
    body{margin:0;padding:0;display:flex;flex-direction:column;min-height:100vh;background:#f6f7fb;color:#111;}
    header{padding:12px;background:var(--accent);color:white;text-align:center;}
    main{flex:1;padding:12px;max-width:920px;margin:0 auto;box-sizing:border-box;}
    .card{background:white;border-radius:10px;padding:12px;box-shadow:0 6px 18px rgba(16,24,40,0.08);margin-bottom:12px;}
    input[type=text]{width:100%;padding:8px;margin-top:6px;border-radius:6px;border:1px solid #ddd}
    button{padding:10px 12px;border-radius:8px;border:0;background:var(--accent);color:white;font-weight:600;margin-top:8px}
    .small{font-size:0.9rem;color:#555}
    .row{display:flex;gap:8px;align-items:center}
    .canvas-wrap{width:100%;height:260px;border-radius:8px;background:linear-gradient(180deg,#fff,#f3f4f6);touch-action:none;display:flex;align-items:center;justify-content:center;overflow:hidden}
    canvas{max-width:100%;height:100%;border-radius:8px}
    .player-swatch {width:18px;height:18px;border-radius:4px;margin-right:8px;border:1px solid #ddd;display:inline-block;vertical-align:middle}
    .palette {display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
    .pal-btn {width:36px;height:36px;border-radius:6px;border:2px solid transparent;cursor:pointer}
    .pal-btn.selected {outline:3px solid rgba(0,0,0,0.08); transform: translateY(-2px)}
    #playerList button{display:block;width:100%;text-align:left;padding:10px;margin-top:6px;border-radius:8px;border:1px solid #eee;background:#fafafa;position:relative}
    #playerList button.done{opacity:0.45}
    #playerList button.current{box-shadow:0 0 0 3px rgba(0,0,0,0.06); animation: pulse 1.2s infinite;}
    @keyframes pulse {0%{box-shadow:0 0 0 0 rgba(0,0,0,0.06);}70%{box-shadow:0 0 0 8px rgba(0,0,0,0.00);}100%{box-shadow:0 0 0 0 rgba(0,0,0,0.00);}}
    .muted{color:#888}
    .notice{padding:8px;border-radius:8px;background:#fff7c2;color:#775a00;margin-top:8px}
  </style>
</head>
<body>
  <header><h1>Wavelength – Spiel</h1></header>
  <main>
    <div class="card" id="setupCard">
      <h2>Spieler anlegen</h2>
      <div class="small">Gib Namen ein und wähle eine Farbe aus der Palette (10 Farben).</div>

      <div style="display:flex;gap:8px;margin-top:8px">
        <input id="playerName" placeholder="Name eingeben" />
        <button id="addPlayer">Hinzufügen</button>
      </div>

      <div class="small" style="margin-top:10px">Farbauswahl:</div>
      <div class="palette" id="palette"></div>

      <div id="playersArea" style="margin-top:10px"></div>

      <hr>
      <div class="small muted">Kategorien: <code>kategorien.csv</code> im Repo-Root (je Zeile 1 Kategorie).</div>

      <div style="margin-top:12px">
        <button id="startGame">Spiel starten</button>
      </div>
    </div>

    <div class="card" id="gameCard" style="display:none">
      <h2>Runde</h2>
      <div id="roundInfo" class="small muted"></div>
      <div style="margin-top:8px">
        <div id="categoryText" class="small" style="margin-top:8px"></div>
      </div>

      <hr>
      <div id="masterArea" style="display:none">
        <div class="small">Spielmacher: <strong id="masterName"></strong></div>
        <div class="canvas-wrap" style="margin-top:8px"><canvas id="canvasMaster"></canvas></div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="showTargetBtn">Ziel kurz anzeigen</button>
          <button id="hideTargetBtn" style="display:none">Ziel verbergen</button>
          <button id="masterDoneBtn">Fertig — Hand weitergeben</button>
        </div>
        <div id="masterHint" class="notice" style="display:none">Zeige das Ziel nur kurz dem Spielmacher, danach verbergen.</div>
      </div>

      <div id="guessArea" style="display:none;margin-top:12px">
        <div class="small">Gib das Handy weiter. Jeder Spieler (außer Spielmacher) wählt seinen Namen, setzt einen Pfeil innerhalb des Halbkreises und bestätigt.</div>
        <div id="playerList" style="margin-top:8px"></div>
        <div class="canvas-wrap" style="margin-top:8px"><canvas id="canvasGuess"></canvas></div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="confirmBtn" style="background:#10b981;display:none">Bestätigen</button>
          <button id="cancelBtn">Abbrechen</button>
        </div>
        <div id="selectNotice" class="small muted" style="margin-top:6px"></div>
      </div>

      <div id="resultsArea" style="display:none;margin-top:12px">
        <h3>Ergebnis & Tabelle</h3>
        <div id="revealCanvasWrap" class="center"></div>
        <div id="scores" style="margin-top:8px"></div>
        <button id="newRoundBtn">Neue Runde</button>
      </div>
    </div>

  </main>
  <footer class="small muted">Speichere <code>kategorien.csv</code> in deinem Repo-Root, eine Kategorie pro Zeile.</footer>

<script>
/* Palette + sichtbare Segment-Rendering
   - 10 feste Farben (Palette)
   - Target wird als 5 Keilsegmente (ring sectors) oberhalb der Halbkugel gezeichnet
   - Pfeile und Player-names sichtbar
*/

const el = id => document.getElementById(id);

// --- Datenmodell ---
let players = []; // {name, color, status:'pending'|'done'|'master'|'current'}
let categories = ["Schlechter Film - Guter Film","Heiß - Kalt","Mutig - Ängstlich"];
let masterIndex = 0;
let targetAngle = null;
let guesses = {};
let currentPicker = null;
let categoryThisRound = '';

// Canvas
let canvasMaster, canvasGuess, mctx, gctx;

// Palette (10 Farben)
const PALETTE = [
  '#ef4444', '#f97316', '#f59e0b', '#eab308', '#84cc16',
  '#10b981', '#06b6d4', '#3b82f6', '#8b5cf6', '#ec4899'
];
let selectedPaletteColor = PALETTE[0];

// --- Helpers ---
function hexToRgb(hex){
  const h = hex.replace('#','');
  const n = parseInt(h,16);
  return [(n>>16)&255,(n>>8)&255,n&255];
}
function rgba(hex,a=1){
  const [r,g,b] = hexToRgb(hex);
  return `rgba(${r},${g},${b},${a})`;
}

// load categories.csv
async function loadCategoriesCSV(){
  try{
    const resp = await fetch('kategorien.csv');
    if(!resp.ok) return;
    const txt = await resp.text();
    const lines = txt.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    if(lines.length) categories = categories.concat(lines);
  }catch(e){
    console.log('CSV load error', e);
  }
}

// --- UI: palette & players list ---
function renderPalette(){
  const wrap = el('palette');
  wrap.innerHTML = '';
  PALETTE.forEach((c,i)=>{
    const b = document.createElement('button');
    b.className = 'pal-btn';
    b.style.background = c;
    if(c === selectedPaletteColor) b.classList.add('selected');
    b.addEventListener('click', ()=>{ selectedPaletteColor = c; document.querySelectorAll('.pal-btn').forEach(x=>x.classList.remove('selected')); b.classList.add('selected'); });
    wrap.appendChild(b);
  });
}

function renderPlayersArea(){
  const area = el('playersArea');
  area.innerHTML = '';
  if(players.length === 0){ area.innerHTML = '<div class="small muted">Keine Spieler</div>'; return; }
  players.forEach((p, idx)=>{
    const div = document.createElement('div');
    div.className = 'row';
    div.style.marginTop = '6px';
    div.innerHTML = `<span class="player-swatch" style="background:${p.color}"></span><div style="flex:1">${idx+1}. <strong>${p.name}</strong> <span class="muted">(${p.status})</span></div><div><button data-i="${idx}" class="removeBtn">Entf.</button></div>`;
    area.appendChild(div);
  });
  document.querySelectorAll('.removeBtn').forEach(b=>b.addEventListener('click', e=>{ const i = +e.currentTarget.dataset.i; players.splice(i,1); renderPlayersArea(); }));
}

// add player
el('addPlayer').addEventListener('click', ()=>{
  const name = el('playerName').value.trim();
  if(!name) return;
  if(players.find(p=>p.name === name)){ alert('Name schon vorhanden'); return; }
  players.push({name, color: selectedPaletteColor, status:'pending'});
  el('playerName').value = '';
  renderPlayersArea();
});

// --- start & round ---
el('startGame').addEventListener('click', async ()=>{
  if(players.length < 2){ alert('Mindestens 2 Spieler'); return; }
  await loadCategoriesCSV();
  el('setupCard').style.display = 'none';
  el('gameCard').style.display = 'block';
  masterIndex = Math.floor(Math.random()*players.length);
  startRound();
});

function startRound(){
  guesses = {}; currentPicker = null;
  players.forEach(p=>p.status='pending');
  players[masterIndex].status = 'master';
  categoryThisRound = categories[Math.floor(Math.random()*categories.length)];
  el('categoryText').textContent = categoryThisRound;
  el('roundInfo').textContent = `Spielmacher: ${players[masterIndex].name}`;
  el('masterName').textContent = players[masterIndex].name;
  // choose center between 2..178 to allow ±2
  targetAngle = Math.floor(Math.random()*(178-2+1))+2;
  console.log('targetAngle', targetAngle);
  el('masterArea').style.display = 'block';
  el('guessArea').style.display = 'none';
  el('resultsArea').style.display = 'none';
  el('masterHint').style.display = 'none';
  el('showTargetBtn').style.display = 'inline-block';
  el('hideTargetBtn').style.display = 'none';
  renderMaster(true); renderGuess();
  renderPlayerList();
}

// --- canvas setup and metrics ---
function setupCanvases(){
  canvasMaster = el('canvasMaster'); canvasGuess = el('canvasGuess');
  mctx = canvasMaster.getContext('2d'); gctx = canvasGuess.getContext('2d');
  function resize(c, ctx, h=220){ const dpi = window.devicePixelRatio||1; const parent = c.parentElement; const w = Math.max(320, parent.clientWidth-12); c.style.width=w+'px'; c.style.height=h+'px'; c.width = Math.floor(w*dpi); c.height = Math.floor(h*dpi); ctx.setTransform(dpi,0,0,dpi,0,0); }
  resize(canvasMaster,mctx,220); resize(canvasGuess,gctx,220);
  window.addEventListener('resize', ()=>{ resize(canvasMaster,mctx,220); resize(canvasGuess,gctx,220); renderMaster(true); renderGuess(); });
}
function metrics(ctx){
  const dpi = window.devicePixelRatio||1;
  const w = ctx.canvas.width / dpi;
  const h = ctx.canvas.height / dpi;
  const cx = w/2; const cy = h-10; const r = Math.min(w/2 - 20, h - 20);
  return {w,h,cx,cy,r};
}

// --- drawing: semicircle base ---
function drawBase(ctx){
  const m = metrics(ctx);
  ctx.clearRect(0,0,ctx.canvas.width/(window.devicePixelRatio||1), ctx.canvas.height/(window.devicePixelRatio||1));
  ctx.beginPath(); ctx.moveTo(m.cx - m.r, m.cy); ctx.arc(m.cx, m.cy, m.r, Math.PI, 0, false); ctx.closePath();
  ctx.fillStyle = '#fff'; ctx.fill();
  ctx.lineWidth = 1.2; ctx.strokeStyle = '#ccc'; ctx.stroke();
  // ticks
  ctx.fillStyle='#666'; ctx.font='12px sans-serif';
  for(let i=0;i<=180;i+=10){
    const ang = Math.PI - (i*Math.PI/180);
    const x1 = m.cx + (m.r-8)*Math.cos(ang); const y1 = m.cy + (m.r-8)*Math.sin(ang);
    const x2 = m.cx + (m.r)*Math.cos(ang); const y2 = m.cy + (m.r)*Math.sin(ang);
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
    if(i%30===0){ const tx = m.cx + (m.r-22)*Math.cos(ang); const ty = m.cy + (m.r-22)*Math.sin(ang)+4; ctx.fillText(String(i), tx-6, ty); }
  }
}

// draw target as 5 visible wedge bands on TOP of semicircle
function drawTargetBandsTop(ctx, centerAngle){
  const m = metrics(ctx);
  const inner = m.r - 12;
  const outer = m.r + 26; // make them clearly outside semicircle
  // helper to draw ring segment (inner..outer)
  function ringSegment(centerDeg, halfWidthDeg, color, label){
    const start = Math.PI - ((centerDeg + halfWidthDeg) * Math.PI/180);
    const end = Math.PI - ((centerDeg - halfWidthDeg) * Math.PI/180);
    // outer arc
    ctx.beginPath();
    ctx.moveTo(m.cx + inner*Math.cos(start), m.cy + inner*Math.sin(start));
    ctx.lineTo(m.cx + outer*Math.cos(start), m.cy + outer*Math.sin(start));
    ctx.arc(m.cx, m.cy, outer, start, end, false);
    ctx.lineTo(m.cx + inner*Math.cos(end), m.cy + inner*Math.sin(end));
    ctx.arc(m.cx, m.cy, inner, end, start, true);
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
    // label near outer center
    const mid = Math.PI - (centerDeg * Math.PI/180);
    const lx = m.cx + (outer + 8) * Math.cos(mid);
    const ly = m.cy + (outer + 8) * Math.sin(mid);
    ctx.fillStyle = '#111';
    ctx.font = 'bold 12px sans-serif';
    ctx.fillText(label, lx-6, ly+4);
  }
  // draw order: outermost (±2 green), then ±1 yellow, then center red above all
  ringSegment(centerAngle+2, 0.9, '#16a34a', '3');
  ringSegment(centerAngle-2, 0.9, '#16a34a', '3');
  ringSegment(centerAngle+1, 0.9, '#f59e0b', '4');
  ringSegment(centerAngle-1, 0.9, '#f59e0b', '4');
  ringSegment(centerAngle, 0.9, '#ef4444', '5');
}

// draw arrow at angle
function drawArrow(ctx, angle, color, label, highlighted=false){
  const m = metrics(ctx);
  const ang = Math.PI - (angle * Math.PI/180);
  const tipX = m.cx + (m.r-6)*Math.cos(ang);
  const tipY = m.cy + (m.r-6)*Math.sin(ang);
  const baseR = m.r - 36;
  const baseX = m.cx + baseR * Math.cos(ang);
  const baseY = m.cy + baseR * Math.sin(ang);
  const ortX = Math.cos(ang - Math.PI/2), ortY = Math.sin(ang - Math.PI/2);
  const w = highlighted ? 10 : 7;
  const p1 = [tipX,tipY];
  const p2 = [baseX + ortX*w, baseY + ortY*w];
  const p3 = [baseX - ortX*w, baseY - ortY*w];
  ctx.beginPath(); ctx.moveTo(p1[0],p1[1]); ctx.lineTo(p2[0],p2[1]); ctx.lineTo(p3[0],p3[1]); ctx.closePath();
  ctx.fillStyle = rgba(color,1); ctx.fill();
  if(highlighted){ ctx.lineWidth=2; ctx.strokeStyle='rgba(0,0,0,0.12)'; ctx.stroke(); }
  const lx = m.cx + (m.r-46) * Math.cos(ang); const ly = m.cy + (m.r-46) * Math.sin(ang);
  ctx.fillStyle = '#111'; ctx.font = highlighted ? 'bold 13px sans-serif' : '12px sans-serif'; ctx.fillText(label, lx+10, ly+4);
}

// draw full master canvas (base + possibly bands)
let masterShow = false;
function renderMaster(showBands=false){
  drawBase(mctx);
  if(showBands || masterShow) drawTargetBandsTop(mctx, targetAngle);
  if(!showBands && !masterShow){
    // overlay subtle hint
    const mm = metrics(mctx);
    mctx.fillStyle='rgba(0,0,0,0.04)'; mctx.fillRect(0,0,mctx.canvas.width/(window.devicePixelRatio||1), mctx.canvas.height/(window.devicePixelRatio||1));
    mctx.fillStyle='#444'; mctx.font='14px sans-serif'; mctx.fillText('Ziel ist versteckt. Nur Spielmacher darf es sehen.', 12,20);
  }
}

// render guess canvas (existing guesses + temp)
function renderGuess(){
  drawBase(gctx);
  // draw confirmed guesses
  Object.entries(guesses).forEach(([name,ang])=>{
    const p = players.find(pp=>pp.name===name);
    if(p) drawArrow(gctx, ang, p.color, name, false);
  });
  // temp selection
  if(currentPicker && tempAngle !== null){
    const p = players.find(pp=>pp.name===currentPicker);
    if(p) drawArrow(gctx, tempAngle, p.color, p.name, true);
  }
}

// --- player list (with statuses) ---
function renderPlayerList(){
  const cont = el('playerList'); cont.innerHTML = '';
  players.forEach(p=>{
    if(p.status === 'master') return;
    const btn = document.createElement('button');
    btn.textContent = p.name;
    btn.classList.remove('done','current');
    if(p.status === 'done') btn.classList.add('done');
    if(p.status === 'current') btn.classList.add('current');
    const sw = document.createElement('span'); sw.className='player-swatch'; sw.style.background=p.color; if(p.status==='done') sw.style.opacity=0.35;
    btn.prepend(sw);
    btn.addEventListener('click', ()=>{
      if(p.status==='done'){ alert('Bereits bestätigt'); return; }
      players.forEach(pp=>{ if(pp.status==='current') pp.status='pending'; });
      p.status='current'; currentPicker = p.name; tempAngle = null;
      el('selectNotice').textContent = `Markiere jetzt: ${p.name}`;
      el('confirmBtn').style.display='inline-block';
      renderPlayerList(); renderGuess();
    });
    cont.appendChild(btn);
  });
}

// --- interaction: picking angle inside semicircle ---
let tempAngle = null;
function canvasToAngle(clientX, clientY, ctx){
  const rect = ctx.canvas.getBoundingClientRect();
  const x = clientX - rect.left; const y = clientY - rect.top;
  const m = metrics(ctx);
  const dx = x - m.cx, dy = y - m.cy; const dist = Math.sqrt(dx*dx + dy*dy);
  if(y > m.cy || dist > m.r + 0.01) return null;
  const ratio = Math.max(0, Math.min(1, x / rect.width));
  return Math.round(ratio*180);
}
function bindGuessCanvas(){
  let drag=false;
  canvasGuess.addEventListener('pointerdown', e=>{
    e.preventDefault();
    drag=true; canvasGuess.setPointerCapture(e.pointerId);
    const a = canvasToAngle(e.clientX, e.clientY, gctx);
    if(a===null){ el('selectNotice').textContent='Nur innerhalb Halbkreis'; setTimeout(()=>el('selectNotice').textContent='',900); return; }
    tempAngle = a; renderGuess();
  });
  canvasGuess.addEventListener('pointermove', e=>{ if(!drag) return; const a = canvasToAngle(e.clientX, e.clientY, gctx); if(a===null) return; tempAngle=a; renderGuess(); });
  canvasGuess.addEventListener('pointerup', e=>{ drag=false; canvasGuess.releasePointerCapture(e.pointerId); });
}

// confirm selection
el('confirmBtn').addEventListener('click', ()=>{
  if(!currentPicker){ alert('Wähle Namen'); return; }
  if(tempAngle===null){ alert('Setze Pfeil'); return; }
  guesses[currentPicker] = tempAngle;
  const p = players.find(pp=>pp.name===currentPicker); if(p) p.status='done';
  currentPicker = null; tempAngle = null;
  el('confirmBtn').style.display='none';
  el('selectNotice').textContent='Gespeichert.';
  renderPlayerList(); renderGuess();
  // check end
  const remaining = players.filter(pp=>pp.status!=='done' && pp.status!=='master');
  if(remaining.length===0){ el('guessArea').style.display='none'; el('resultsArea').style.display='block'; renderReveal(false); renderScores(); }
});

// cancel/back
el('cancelBtn').addEventListener('click', ()=>{ if(currentPicker){ const p = players.find(pp=>pp.name===currentPicker); if(p) p.status='pending'; currentPicker=null; tempAngle=null; el('confirmBtn').style.display='none'; el('selectNotice').textContent=''; renderPlayerList(); renderGuess(); } });

// master show/hide
el('showTargetBtn').addEventListener('click', ()=>{ masterShow = true; el('masterHint').style.display='block'; el('showTargetBtn').style.display='none'; el('hideTargetBtn').style.display='inline-block'; renderMaster(true); });
el('hideTargetBtn').addEventListener('click', ()=>{ masterShow=false; el('masterHint').style.display='none'; el('hideTargetBtn').style.display='none'; el('showTargetBtn').style.display='inline-block'; renderMaster(false); });
el('masterDoneBtn').addEventListener('click', ()=>{ el('masterArea').style.display='none'; el('guessArea').style.display='block'; renderGuess(); renderPlayerList(); bindGuessCanvas(); });

// reveal and scoring
function renderReveal(showTarget){
  // create preview canvas sized like guess
  const w = canvasGuess.parentElement.clientWidth, h=220;
  const c = document.createElement('canvas'); const dpi = window.devicePixelRatio||1;
  c.width = Math.floor(w*dpi); c.height = Math.floor(h*dpi); c.style.width = w+'px'; c.style.height = h+'px';
  const ctx = c.getContext('2d'); ctx.setTransform(dpi,0,0,dpi,0,0);
  drawBase(ctx);
  // draw guesses
  Object.entries(guesses).forEach(([name,ang])=>{ const p = players.find(pp=>pp.name===name); if(p) drawArrowAtPreview(ctx, ang, p.color, name); });
  if(showTarget) drawTargetBandsTop(ctx, targetAngle);
  const wrap = el('revealCanvasWrap'); wrap.innerHTML=''; wrap.appendChild(c);
  if(!showTarget){ const btn = document.createElement('button'); btn.textContent='Aufdecken (Ziel sichtbar)'; btn.style.marginTop='8px'; btn.onclick = ()=>{ renderReveal(true); renderScores(); }; wrap.appendChild(btn); }
}
function drawArrowAtPreview(ctx, angle, color, label){
  // simple arrow for preview reusing drawArrow function via metrics hack: create temp ctx wrapper
  // We'll implement small arrow similar to drawArrow
  const m = (function(){ const dpi = window.devicePixelRatio||1; const w = ctx.canvas.width/dpi; const h = ctx.canvas.height/dpi; return {cx:w/2,cy:h-10,r:Math.min(w/2-20,h-20)} })();
  const ang = Math.PI - (angle * Math.PI/180);
  const tipX = m.cx + (m.r-6)*Math.cos(ang); const tipY = m.cy + (m.r-6)*Math.sin(ang);
  const baseR = m.r -36; const baseX = m.cx + baseR*Math.cos(ang); const baseY = m.cy + baseR*Math.sin(ang);
  const ortX = Math.cos(ang - Math.PI/2), ortY = Math.sin(ang - Math.PI/2); const w2 = 8;
  const p1=[tipX,tipY], p2=[baseX+ortX*w2, baseY+ortY*w2], p3=[baseX-ortX*w2, baseY-ortY*w2];
  ctx.beginPath(); ctx.moveTo(p1[0],p1[1]); ctx.lineTo(p2[0],p2[1]); ctx.lineTo(p3[0],p3[1]); ctx.closePath();
  ctx.fillStyle = rgba(color,1); ctx.fill(); ctx.fillStyle='#111'; ctx.font='12px sans-serif'; ctx.fillText(label, baseX+10, baseY+4);
}

function renderRevealCanvas(revealTarget){ renderReveal(revealTarget); }
function renderScores(){
  const scores={}; players.forEach(p=>scores[p.name]=0);
  Object.entries(guesses).forEach(([name,ang])=>{ const d=Math.abs(ang-targetAngle); const pts=(d===0)?5:(d===1)?4:(d===2)?3:0; scores[name]+=pts; });
  const node = el('scores'); node.innerHTML=''; const arr = Object.entries(scores).filter(([n])=> n!==players[masterIndex].name).sort((a,b)=>b[1]-a[1]);
  arr.forEach(([name,pts])=>{ const p = players.find(pp=>pp.name===name); const sw = `<span style="display:inline-block;width:12px;height:12px;background:${p.color};border-radius:3px;margin-right:8px"></span>`; const div = document.createElement('div'); div.className='leader'; div.innerHTML = `<div>${sw}${name}</div><div>${pts} P</div>`; node.appendChild(div); });
  const md = document.createElement('div'); md.className='small muted'; md.textContent = 'Spielmacher: '+players[masterIndex].name; node.appendChild(md);
}

el('newRoundBtn').addEventListener('click', ()=>{ masterIndex = (masterIndex+1)%players.length; startRound(); });

// init on load
function init(){
  renderPalette();
  setupCanvases();
  renderPlayersArea();
}
init();
</script>
</body>
</html>
