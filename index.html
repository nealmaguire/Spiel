<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Wavelength - Spiel (Fix Winkel/Drag)</title>
<style>
  :root{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;--accent:#2563eb}
  body{margin:0;padding:0;display:flex;flex-direction:column;min-height:100vh;background:#f6f7fb;color:#111}
  header{padding:12px;background:var(--accent);color:white;text-align:center}
  main{flex:1;padding:12px;max-width:920px;margin:0 auto;box-sizing:border-box}
  .card{background:white;border-radius:10px;padding:12px;box-shadow:0 6px 18px rgba(16,24,40,0.08);margin-bottom:12px}
  input[type=text]{width:100%;padding:8px;margin-top:6px;border-radius:6px;border:1px solid #ddd}
  button{padding:10px 12px;border-radius:8px;border:0;background:var(--accent);color:white;font-weight:600;margin-top:8px}
  .small{font-size:0.9rem;color:#555}
  .row{display:flex;gap:8px;align-items:center}
  .canvas-wrap{width:100%;height:300px;border-radius:8px;background:linear-gradient(180deg,#fff,#f3f4f6);touch-action:none;display:flex;align-items:center;justify-content:center;overflow:hidden}
  canvas{max-width:100%;height:100%;border-radius:8px;display:block}
  .palette{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
  .pal-btn{width:36px;height:36px;border-radius:6px;border:2px solid transparent;cursor:pointer}
  .pal-btn.selected{outline:3px solid rgba(0,0,0,0.06);transform:translateY(-2px)}
  .player-swatch{width:18px;height:18px;border-radius:4px;margin-right:8px;border:1px solid #ddd;display:inline-block;vertical-align:middle}
  #playerList button{display:block;width:100%;text-align:left;padding:10px;margin-top:6px;border-radius:8px;border:1px solid #eee;background:#fafafa;position:relative;color:black}
  #playerList button.done{opacity:0.45}
  #playerList button.current{box-shadow:0 0 0 3px rgba(0,0,0,0.06);animation:pulse 1.2s infinite}
  @keyframes pulse{0%{box-shadow:0 0 0 0 rgba(0,0,0,0.06)}70%{box-shadow:0 0 0 8px rgba(0,0,0,0)}100%{box-shadow:0 0 0 0 rgba(0,0,0,0)}}
  .muted{color:#888}
  .notice{padding:8px;border-radius:8px;background:#fff7c2;color:#775a00;margin-top:8px}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  .confirm-btn{background:#10b981}
  .name-input{flex:1}
  .muted-small{color:#999;font-size:0.9rem}
</style>
</head>
<body>
<header><h1>Wavelength – Spiel</h1></header>
<main>
  <div class="card" id="setupCard">
    <h2>Spieler anlegen</h2>
    <div class="small">Gib Namen ein und wähle eine Farbe aus der Palette (10 Farben).</div>

    <div style="display:flex;gap:8px;margin-top:8px">
      <input id="playerName" class="name-input" placeholder="Name eingeben" />
      <button id="addPlayer">Hinzufügen</button>
    </div>

    <div class="small" style="margin-top:10px">Farbauswahl:</div>
    <div class="palette" id="palette"></div>

    <div id="playersArea" style="margin-top:10px"></div>

    <hr>
    <div class="muted-small">Die Kategorien werden automatisch aus <code>kategorien.csv</code> geladen (je Zeile 1 Kategorie).</div>

    <div style="margin-top:12px">
      <button id="startGame">Spiel starten</button>
    </div>
  </div>

  <div class="card" id="gameCard" style="display:none">
    <h2>Runde</h2>
    <div id="roundInfo" class="small muted"></div>
    <div style="margin-top:8px">
      <div id="categoryText" class="small" style="margin-top:8px"></div>
    </div>

    <hr>
    <div id="masterArea" style="display:none">
      <div class="small">Spielmacher: <strong id="masterName"></strong></div>
      <div class="canvas-wrap" style="margin-top:8px"><canvas id="canvasMaster"></canvas></div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="showTargetBtn">Ziel kurz anzeigen</button>
        <button id="hideTargetBtn" style="display:none">Ziel verbergen</button>
        <button id="masterDoneBtn">Fertig — Hand weitergeben</button>
      </div>
      <div id="masterHint" class="notice" style="display:none">Zeige das Ziel nur kurz dem Spielmacher, danach verbergen.</div>
    </div>

    <div id="guessArea" style="display:none;margin-top:12px">
      <div class="small">Gib das Handy weiter. Jeder Spieler (außer Spielmacher) wählt seinen Namen, zieht den Pfeil entlang des Halbkreises und bestätigt.</div>
      <div id="playerList" style="margin-top:8px"></div>
      <div class="canvas-wrap" style="margin-top:8px"><canvas id="canvasGuess"></canvas></div>
      <div class="controls" style="margin-top:8px">
        <button id="confirmBtn" class="confirm-btn" style="display:none">Bestätigen</button>
        <button id="cancelBtn">Abbrechen</button>
      </div>
      <div id="selectNotice" class="small muted" style="margin-top:6px"></div>
    </div>

    <div id="resultsArea" style="display:none;margin-top:12px">
      <h3>Ergebnis & Tabelle</h3>
      <div id="revealCanvasWrap" class="center"></div>
      <div id="scores" style="margin-top:8px"></div>
      <button id="newRoundBtn">Neue Runde</button>
    </div>
  </div>
</main>
<footer class="small muted">Speichere <code>kategorien.csv</code> in deinem Repo-Root, eine Kategorie pro Zeile.</footer>

<script>
// ---------- Daten & Palette ----------
const el = id => document.getElementById(id);
const PALETTE = ['#ef4444','#f97316','#f59e0b','#eab308','#84cc16','#10b981','#06b6d4','#3b82f6','#8b5cf6','#ec4899'];
let selectedPaletteColor = PALETTE[0];
let players = []; // {name,color,status}
let categories = ["Schlechter Film - Guter Film","Heiß - Kalt","Mutig - Ängstlich"];
let masterIndex = 0;
let targetAngle = null;
let guesses = {};
let currentPicker = null;
let categoryThisRound = '';
let canvasMaster, canvasGuess, mctx, gctx;

// helpers
function hexToRgb(hex){ const h=hex.replace('#',''); const n=parseInt(h,16); return [(n>>16)&255,(n>>8)&255,n&255]; }
function rgba(hex,a=1){ const [r,g,b]=hexToRgb(hex); return `rgba(${r},${g},${b},${a})`; }

// load categories.csv
async function loadCategoriesCSV(){
  try{
    const resp = await fetch('kategorien.csv');
    if(!resp.ok) return;
    const txt = await resp.text();
    const lines = txt.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    if(lines.length) categories = categories.concat(lines);
  }catch(e){ console.log('CSV load error', e); }
}

// ---------- UI: palette & players ----------
function renderPalette(){
  const wrap = el('palette'); wrap.innerHTML='';
  PALETTE.forEach(c=>{
    const b = document.createElement('button'); b.className='pal-btn'; b.style.background=c;
    if(c===selectedPaletteColor) b.classList.add('selected');
    b.addEventListener('click', ()=>{ selectedPaletteColor=c; document.querySelectorAll('.pal-btn').forEach(x=>x.classList.remove('selected')); b.classList.add('selected'); });
    wrap.appendChild(b);
  });
}
function renderPlayersArea(){
  const area = el('playersArea'); area.innerHTML='';
  if(players.length===0){ area.innerHTML='<div class="small muted">Keine Spieler</div>'; return; }
  players.forEach((p,i)=>{
    const div=document.createElement('div'); div.className='row'; div.style.marginTop='6px';
    div.innerHTML = `<span class="player-swatch" style="background:${p.color}"></span><div style="flex:1;color:black">${i+1}. <strong>${p.name}</strong> <span style="color:#888">(${p.status})</span></div><div><button data-i="${i}" class="removeBtn">Entf.</button></div>`;
    area.appendChild(div);
  });
  document.querySelectorAll('.removeBtn').forEach(b=>b.addEventListener('click', e=>{ players.splice(+e.currentTarget.dataset.i,1); renderPlayersArea(); }));
}
el('addPlayer').addEventListener('click', ()=>{ const name = el('playerName').value.trim(); if(!name) return; if(players.find(p=>p.name===name)){ alert('Name bereits vorhanden'); return; } players.push({name, color:selectedPaletteColor, status:'pending'}); el('playerName').value=''; renderPlayersArea(); });

// ---------- Start / Runde ----------
el('startGame').addEventListener('click', async ()=>{
  if(players.length < 2){ alert('Mindestens 2 Spieler'); return; }
  await loadCategoriesCSV();
  el('setupCard').style.display='none'; el('gameCard').style.display='block';
  masterIndex = Math.floor(Math.random()*players.length);
  startRound();
});
function startRound(){
  guesses = {}; currentPicker = null;
  players.forEach(p=>p.status='pending');
  players[masterIndex].status='master';
  categoryThisRound = categories[Math.floor(Math.random()*categories.length)];
  el('categoryText').textContent = categoryThisRound;
  el('roundInfo').textContent = `Spielmacher: ${players[masterIndex].name}`;
  el('masterName').textContent = players[masterIndex].name;
  // center between 2..178
  targetAngle = Math.floor(Math.random()*(178-2+1))+2;
  console.log('targetAngle', targetAngle);
  el('masterArea').style.display='block'; el('guessArea').style.display='none'; el('resultsArea').style.display='none';
  el('masterHint').style.display='none'; el('showTargetBtn').style.display='inline-block'; el('hideTargetBtn').style.display='none';
  renderMaster(false); renderGuess(); renderPlayerList();
}

// ---------- Canvas setup & metrics ----------
function setupCanvases(){
  canvasMaster = el('canvasMaster'); canvasGuess = el('canvasGuess');
  mctx = canvasMaster.getContext('2d'); gctx = canvasGuess.getContext('2d');
  function resize(c,ctx,h=260){ const dpi = window.devicePixelRatio||1; const parent=c.parentElement; const w = Math.max(320, parent.clientWidth-12); c.style.width = w+'px'; c.style.height = h+'px'; c.width = Math.floor(w*dpi); c.height = Math.floor(h*dpi); ctx.setTransform(dpi,0,0,dpi,0,0); }
  resize(canvasMaster,mctx,260); resize(canvasGuess,gctx,260);
  window.addEventListener('resize', ()=>{ resize(canvasMaster,mctx,260); resize(canvasGuess,gctx,260); renderMaster(false); renderGuess(); });
}
function metrics(ctx){
  const dpi = window.devicePixelRatio||1;
  const w = ctx.canvas.width / dpi;
  const h = ctx.canvas.height / dpi;
  const cx = w/2;
  const cy = h - 16; // center near bottom so semicircle opens upwards
  const r = Math.min(w/2 - 20, h - 30);
  return {w,h,cx,cy,r};
}

// ---------- Drawing ----------
function drawBase(ctx){
  const m = metrics(ctx);
  ctx.clearRect(0,0,ctx.canvas.width/(window.devicePixelRatio||1), ctx.canvas.height/(window.devicePixelRatio||1));
  ctx.beginPath(); ctx.moveTo(m.cx - m.r, m.cy); ctx.arc(m.cx, m.cy, m.r, Math.PI, 0, false); ctx.closePath();
  ctx.fillStyle='#ffffff'; ctx.fill();
  ctx.lineWidth=1.2; ctx.strokeStyle='#bfc7d6'; ctx.stroke();
  // ticks
  ctx.fillStyle='#666'; ctx.font='12px sans-serif';
  for(let i=0;i<=180;i+=10){
    const ang = Math.PI - (i*Math.PI/180);
    const x1 = m.cx + (m.r-8)*Math.cos(ang), y1 = m.cy + (m.r-8)*Math.sin(ang);
    const x2 = m.cx + (m.r)*Math.cos(ang), y2 = m.cy + (m.r)*Math.sin(ang);
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
    if(i%30===0){
      const tx = m.cx + (m.r-22)*Math.cos(ang), ty = m.cy + (m.r-22)*Math.sin(ang)+4;
      ctx.fillText(String(i), tx-6, ty);
    }
  }
}

// draw colored wedges inside semicircle
function drawTargetSegmentsInside(ctx, centerAngle){
  const m = metrics(ctx);
  const outer = m.r - 4;
  const inner = Math.max(m.r - 80, m.r * 0.45);
  function wedge(angleDeg, halfDeg, color, label){
    const start = Math.PI - ((angleDeg + halfDeg) * Math.PI/180);
    const end   = Math.PI - ((angleDeg - halfDeg) * Math.PI/180);
    ctx.beginPath();
    ctx.moveTo(m.cx + inner*Math.cos(start), m.cy + inner*Math.sin(start));
    ctx.lineTo(m.cx + outer*Math.cos(start), m.cy + outer*Math.sin(start));
    ctx.arc(m.cx, m.cy, outer, start, end, false);
    ctx.lineTo(m.cx + inner*Math.cos(end), m.cy + inner*Math.sin(end));
    ctx.arc(m.cx, m.cy, inner, end, start, true);
    ctx.closePath();
    ctx.fillStyle = color; ctx.fill();
    // label
    const mid = Math.PI - (angleDeg * Math.PI/180);
    const lx = m.cx + (inner + (outer-inner)/2) * Math.cos(mid);
    const ly = m.cy + (inner + (outer-inner)/2) * Math.sin(mid);
    ctx.fillStyle = '#111'; ctx.font = 'bold 11px sans-serif'; ctx.fillText(label, lx-6, ly+4);
  }
  // draw order ensures center on top
  wedge(centerAngle+2, 0.9, '#16a34a', '3');
  wedge(centerAngle-2, 0.9, '#16a34a', '3');
  wedge(centerAngle+1, 0.9, '#f59e0b', '4');
  wedge(centerAngle-1, 0.9, '#f59e0b', '4');
  wedge(centerAngle,   0.9, '#ef4444', '5');
}

// arrow drawing
function drawArrow(ctx, angle, color, label, highlighted=false){
  const m = metrics(ctx);
  const ang = Math.PI - (angle * Math.PI/180);
  const tipX = m.cx + (m.r-6)*Math.cos(ang), tipY = m.cy + (m.r-6)*Math.sin(ang);
  const baseR = m.r - 42;
  const baseX = m.cx + baseR*Math.cos(ang), baseY = m.cy + baseR*Math.sin(ang);
  const ortX = Math.cos(ang - Math.PI/2), ortY = Math.sin(ang - Math.PI/2);
  const half = highlighted ? 12 : 8;
  const p1=[tipX,tipY], p2=[baseX+ortX*half, baseY+ortY*half], p3=[baseX-ortX*half, baseY-ortY*half];
  ctx.beginPath(); ctx.moveTo(p1[0],p1[1]); ctx.lineTo(p2[0],p2[1]); ctx.lineTo(p3[0],p3[1]); ctx.closePath();
  ctx.fillStyle = rgba(color,1); ctx.fill();
  if(highlighted){ ctx.lineWidth=2; ctx.strokeStyle='rgba(0,0,0,0.12)'; ctx.stroke(); }
  const lx = m.cx + (m.r-56)*Math.cos(ang), ly = m.cy + (m.r-56)*Math.sin(ang);
  ctx.fillStyle = '#000'; ctx.font = highlighted ? 'bold 13px sans-serif' : '12px sans-serif'; ctx.fillText(label, lx + 10, ly + 4);
}

// ---------- Render functions ----------
let masterShow = false;
function renderMaster(force=false){
  drawBase(mctx);
  if(force || masterShow) drawTargetSegmentsInside(mctx, targetAngle);
  if(!force && !masterShow){
    const mm = metrics(mctx);
    mctx.fillStyle='rgba(0,0,0,0.03)';
    mctx.fillRect(0,0,mctx.canvas.width/(window.devicePixelRatio||1), mctx.canvas.height/(window.devicePixelRatio||1));
    mctx.fillStyle='#444'; mctx.font='14px sans-serif';
    mctx.fillText('Ziel ist versteckt. Nur Spielmacher darf es sehen.', 12, 20);
  }
}

let tempAngle = null;
function renderGuess(){
  drawBase(gctx);
  // confirmed
  Object.entries(guesses).forEach(([name,angle])=>{
    const p = players.find(pp=>pp.name===name);
    if(p) drawArrow(gctx, angle, p.color, name, false);
  });
  // temp
  if(currentPicker && tempAngle !== null){
    const p = players.find(pp=>pp.name===currentPicker);
    if(p) drawArrow(gctx, tempAngle, p.color, p.name, true);
  }
}

// ---------- Player list ----------
function renderPlayerList(){
  const cont = el('playerList'); cont.innerHTML='';
  players.forEach(p=>{
    if(p.status==='master') return;
    const btn = document.createElement('button');
    btn.textContent = p.name; btn.style.color='black';
    btn.classList.remove('done','current');
    if(p.status==='done') btn.classList.add('done');
    if(p.status==='current') btn.classList.add('current');
    const sw = document.createElement('span'); sw.className='player-swatch'; sw.style.background=p.color; if(p.status==='done') sw.style.opacity=0.35;
    btn.prepend(sw);
    btn.addEventListener('click', ()=>{
      if(p.status==='done'){ alert('Dieser Spieler hat bereits bestätigt.'); return; }
      players.forEach(pp=>{ if(pp.status==='current') pp.status='pending'; });
      p.status='current'; currentPicker=p.name; tempAngle=null;
      el('selectNotice').textContent=`Markiere jetzt: ${p.name}`;
      el('confirmBtn').style.display='inline-block';
      renderPlayerList(); renderGuess();
    });
    cont.appendChild(btn);
  });
}

// ---------- Pointer -> Winkel (Korrektur) ----------
function canvasToAngle(clientX, clientY, ctx){
  const rect = ctx.canvas.getBoundingClientRect();
  const x = clientX - rect.left, y = clientY - rect.top;
  const m = metrics(ctx);
  // compute raw angle using atan2(y - cy, x - cx)
  const dx = x - m.cx, dy = y - m.cy;
  const deg = Math.atan2(dy, dx) * 180 / Math.PI; // -180 .. 180
  // normalize: left = 0, top = 90, right = 180
  const angleDeg = (deg + 180 + 360) % 360; // make positive
  if(angleDeg < 0 || angleDeg > 360) return null;
  // accept only 0..180 (upper semicircle)
  if(angleDeg < 0 || angleDeg > 180) return null;
  // also check distance to center to be within reasonable arc (allow some tolerance)
  const dist = Math.sqrt(dx*dx + dy*dy);
  if(y > m.cy + 6 || dist > m.r + 6) return null;
  return Math.round(angleDeg);
}

// ---------- Drag binding (arrow along arc) ----------
function bindGuessDrag(){
  let dragging = false;
  canvasGuess.addEventListener('pointerdown', e=>{
    if(!currentPicker) return;
    dragging = true; canvasGuess.setPointerCapture(e.pointerId);
    const a = canvasToAngle(e.clientX, e.clientY, gctx);
    if(a === null){ el('selectNotice').textContent='Nur entlang des Halbkreises wählen.'; setTimeout(()=>el('selectNotice').textContent='',900); return; }
    tempAngle = a; renderGuess();
  });
  canvasGuess.addEventListener('pointermove', e=>{
    if(!dragging) return;
    const a = canvasToAngle(e.clientX, e.clientY, gctx);
    if(a === null) return;
    tempAngle = a; renderGuess();
  });
  canvasGuess.addEventListener('pointerup', e=>{
    dragging = false; canvasGuess.releasePointerCapture(e.pointerId);
  });
}

// ---------- Confirm / Cancel ----------
el('confirmBtn').addEventListener('click', ()=>{
  if(!currentPicker){ alert('Wähle zuerst deinen Namen'); return; }
  if(tempAngle === null){ alert('Ziehe zuerst den Pfeil'); return; }
  guesses[currentPicker] = tempAngle;
  const p = players.find(pp=>pp.name===currentPicker); if(p) p.status='done';
  currentPicker = null; tempAngle = null;
  el('confirmBtn').style.display='none'; el('selectNotice').textContent='Markierung gespeichert.'; setTimeout(()=>el('selectNotice').textContent='',900);
  renderPlayerList(); renderGuess();
  const remaining = players.filter(pp=>pp.status!=='done' && pp.status!=='master');
  if(remaining.length === 0){ el('guessArea').style.display='none'; el('resultsArea').style.display='block'; renderReveal(false); renderScores(); }
});
el('cancelBtn').addEventListener('click', ()=>{ if(currentPicker){ const p=players.find(pp=>pp.name===currentPicker); if(p) p.status='pending'; currentPicker=null; tempAngle=null; el('confirmBtn').style.display='none'; el('selectNotice').textContent=''; renderPlayerList(); renderGuess(); } });

// ---------- Master show/hide ----------
el('showTargetBtn').addEventListener('click', ()=>{ masterShow=true; el('masterHint').style.display='block'; el('showTargetBtn').style.display='none'; el('hideTargetBtn').style.display='inline-block'; renderMaster(true); });
el('hideTargetBtn').addEventListener('click', ()=>{ masterShow=false; el('masterHint').style.display='none'; el('hideTargetBtn').style.display='none'; el('showTargetBtn').style.display='inline-block'; renderMaster(false); });
el('masterDoneBtn').addEventListener('click', ()=>{ el('masterArea').style.display='none'; el('guessArea').style.display='block'; renderGuess(); renderPlayerList(); bindGuessDrag(); });

// ---------- Reveal & scoring ----------
function renderReveal(showTarget){
  const w = canvasGuess.parentElement.clientWidth, h=220; const c = document.createElement('canvas'); const dpi = window.devicePixelRatio||1;
  c.width = Math.floor(w*dpi); c.height = Math.floor(h*dpi); c.style.width = w+'px'; c.style.height = h+'px';
  const ctx = c.getContext('2d'); ctx.setTransform(dpi,0,0,dpi,0,0);
  drawBase(ctx);
  Object.entries(guesses).forEach(([name,ang])=>{ const p=players.find(pp=>pp.name===name); if(p) drawArrow(ctx, ang, p.color, name, false); });
  if(showTarget) drawTargetSegmentsInside(ctx, targetAngle);
  const wrap = el('revealCanvasWrap'); wrap.innerHTML=''; wrap.appendChild(c);
  if(!showTarget){ const btn = document.createElement('button'); btn.textContent='Aufdecken (Ziel sichtbar)'; btn.style.marginTop='8px'; btn.onclick = ()=>{ renderReveal(true); renderScores(); }; wrap.appendChild(btn); }
}
function renderRevealCanvas(revealTarget){ renderReveal(revealTarget); }
function renderScores(){
  const scores={}; players.forEach(p=>scores[p.name]=0);
  Object.entries(guesses).forEach(([name,ang])=>{ const d=Math.abs(ang-targetAngle); const pts=(d===0)?5:(d===1)?4:(d===2)?3:0; scores[name]+=pts; });
  const node = el('scores'); node.innerHTML='';
  const arr = Object.entries(scores).filter(([n])=> n !== players[masterIndex].name).sort((a,b)=>b[1]-a[1]);
  arr.forEach(([name,pts])=>{ const p = players.find(pp=>pp.name===name); const sw = `<span style="display:inline-block;width:12px;height:12px;background:${p.color};border-radius:3px;margin-right:8px"></span>`; const div = document.createElement('div'); div.className='leader'; div.innerHTML = `<div>${sw}${name}</div><div>${pts} P</div>`; node.appendChild(div); });
  const md = document.createElement('div'); md.className='small muted'; md.textContent = 'Spielmacher: '+players[masterIndex].name; node.appendChild(md);
}
el('newRoundBtn').addEventListener('click', ()=>{ masterIndex = (masterIndex+1) % players.length; startRound(); });

// ---------- Init ----------
function init(){ renderPalette(); setupCanvases(); renderPlayersArea(); }
init();

</script>
</body>
</html>
