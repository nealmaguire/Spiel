<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Wavelength - Spiel (Update)</title>
<style>
  :root{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;--accent:#2563eb}
  body{margin:0;padding:0;display:flex;flex-direction:column;min-height:100vh;background:#f6f7fb;color:#111}
  header{padding:12px;background:var(--accent);color:white;text-align:center}
  main{flex:1;padding:12px;max-width:920px;margin:0 auto;box-sizing:border-box}
  .card{background:white;border-radius:10px;padding:12px;box-shadow:0 6px 18px rgba(16,24,40,0.08);margin-bottom:12px}
  input[type=text]{width:100%;padding:8px;margin-top:6px;border-radius:6px;border:1px solid #ddd}
  button{padding:10px 12px;border-radius:8px;border:0;background:var(--accent);color:white;font-weight:600;margin-top:8px}
  button.secondary{background:#4b5563}
  .small{font-size:0.9rem;color:#555}
  .row{display:flex;gap:8px;align-items:center}
  .canvas-wrap{width:100%;height:360px;border-radius:8px;background:linear-gradient(180deg,#fff,#f3f4f6);touch-action:none;display:flex;align-items:center;justify-content:center;overflow:hidden}
  canvas{max-width:100%;height:100%;border-radius:8px;display:block}
  .palette{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
  .pal-btn{width:36px;height:36px;border-radius:6px;border:2px solid transparent;cursor:pointer}
  .pal-btn.disabled{opacity:0.35;cursor:default;transform:none;pointer-events:none}
  .pal-btn.selected{outline:3px solid rgba(0,0,0,0.06);transform:translateY(-2px)}
  .player-swatch{width:18px;height:18px;border-radius:4px;margin-right:8px;border:1px solid #ddd;display:inline-block;vertical-align:middle}
  #playerList button{display:block;width:100%;text-align:left;padding:10px;margin-top:6px;border-radius:8px;border:1px solid #eee;background:#fafafa;position:relative;color:black}
  #playerList button.done{opacity:0.45}
  #playerList button.current{box-shadow:0 0 0 3px rgba(0,0,0,0.06);animation:pulse 1.2s infinite}
  @keyframes pulse{0%{box-shadow:0 0 0 0 rgba(0,0,0,0.06)}70%{box-shadow:0 0 0 8px rgba(0,0,0,0)}100%{box-shadow:0 0 0 0 rgba(0,0,0,0)}}
  .muted{color:#888}
  .notice{padding:8px;border-radius:8px;background:#fff7c2;color:#775a00;margin-top:8px}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  .confirm-btn{background:#10b981}
  .name-input{flex:1}
  .muted-small{color:#999;font-size:0.9rem}
  .center{display:flex;align-items:center;justify-content:center;flex-direction:column}
</style>
</head>
<body>
<header><h1>Wavelength – Spiel</h1></header>
<main>
  <div class="card" id="setupCard">
    <h2>Spieler anlegen</h2>
    <div class="small">Gib Namen ein und wähle eine Farbe (jede Farbe nur einmal verfügbar).</div>

    <div style="display:flex;gap:8px;margin-top:8px">
      <input id="playerName" class="name-input" placeholder="Name eingeben" />
      <button id="addPlayer">Hinzufügen</button>
    </div>

    <div class="small" style="margin-top:10px">Farbauswahl (10 Farben):</div>
    <div class="palette" id="palette"></div>

    <div id="playersArea" style="margin-top:10px"></div>

    <hr>
    <div class="muted-small">Die Kategorien werden automatisch aus <code>kategorien.csv</code> geladen (je Zeile 1 Kategorie).</div>

    <div style="margin-top:12px">
      <button id="startGame">Spiel starten</button>
    </div>
  </div>

  <div class="card" id="gameCard" style="display:none">
    <h2>Runde</h2>
    <div id="roundInfo" class="small muted"></div>
    <div style="margin-top:8px">
      <div id="categoryText" class="small" style="margin-top:8px"></div>
    </div>

    <hr>
    <div id="masterArea" style="display:none">
      <div class="small">Spielmacher: <strong id="masterName"></strong></div>
      <div class="canvas-wrap" style="margin-top:8px"><canvas id="canvasMaster"></canvas></div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="showTargetBtn">Ziel kurz anzeigen</button>
        <button id="hideTargetBtn" style="display:none">Ziel verbergen</button>
        <button id="masterDoneBtn">Fertig — Hand weitergeben</button>
      </div>
      <div id="masterHint" class="notice" style="display:none">Zeige das Ziel nur kurz dem Spielmacher, danach verbergen.</div>
    </div>

    <div id="guessArea" style="display:none;margin-top:12px">
      <div class="small">Gib das Handy weiter. Jeder Spieler (außer Spielmacher) wählt seinen Namen, zieht den Pfeil entlang des Halbkreises und bestätigt.</div>
      <div id="playerList" style="margin-top:8px"></div>
      <div class="canvas-wrap" style="margin-top:8px"><canvas id="canvasGuess"></canvas></div>
      <div class="controls" style="margin-top:8px">
        <button id="confirmBtn" class="confirm-btn" style="display:none">Bestätigen</button>
        <button id="cancelBtn" class="secondary">Abbrechen</button>
      </div>
      <div id="selectNotice" class="small muted" style="margin-top:6px"></div>
    </div>

    <div id="resultsArea" style="display:none;margin-top:12px">
      <h3>Ergebnis</h3>
      <div id="postRoundNotice" class="notice" style="display:none"></div>
      <div style="margin-top:8px" id="postRoundControls"></div>
      <div id="revealCanvasWrap" class="center" style="margin-top:12px; width:100%"></div>
      <div id="scores" style="margin-top:8px"></div>
      <div style="margin-top:8px"><button id="newRoundBtn">Neue Runde</button></div>
    </div>
  </div>
</main>
<footer class="small muted">Speichere <code>kategorien.csv</code> in deinem Repo-Root, eine Kategorie pro Zeile.</footer>

<script>
// ----------------- Datenmodell & Konstanten -----------------
const el = id => document.getElementById(id);
const PALETTE = ['#ef4444','#f97316','#f59e0b','#eab308','#84cc16','#10b981','#06b6d4','#3b82f6','#8b5cf6','#ec4899'];
let selectedPaletteColor = PALETTE[0];
let players = []; // {name,color,status: 'pending'|'master'|'current'|'done'}
let categories = ["Schlechter Film - Guter Film","Heiß - Kalt","Mutig - Ängstlich"];
let masterIndex = 0;
let targetAngle = null; // 0..180
let confirmedGuesses = {}; // name -> angle
let currentPicker = null; // name of player currently picking
let tempAngle = null;
let canvasMaster, canvasGuess, mctx, gctx;

// helper colors
function hexToRgb(hex){ const h=hex.replace('#',''); const n=parseInt(h,16); return [(n>>16)&255,(n>>8)&255,n&255]; }
function rgba(hex,a=1){ const [r,g,b]=hexToRgb(hex); return `rgba(${r},${g},${b},${a})`; }

// --------------- Kategorien CSV laden -----------------
async function loadCategoriesCSV(){
  try{
    const resp = await fetch('kategorien.csv');
    if(!resp.ok) return;
    const txt = await resp.text();
    const lines = txt.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    if(lines.length) categories = categories.concat(lines);
  }catch(e){ console.log('CSV load error', e); }
}

// --------------- Palette & Spieler UI -----------------
function renderPalette(){
  const wrap = el('palette'); wrap.innerHTML='';
  PALETTE.forEach(c=>{
    const used = players.some(p=>p.color === c);
    const b = document.createElement('button');
    b.className = 'pal-btn' + (used ? ' disabled' : '');
    b.style.background = c;
    if(c === selectedPaletteColor && !used) b.classList.add('selected');
    b.title = used ? 'Bereits gewählt' : 'Wähle diese Farbe';
    if(!used){
      b.addEventListener('click', ()=>{
        selectedPaletteColor = c;
        document.querySelectorAll('.pal-btn').forEach(x=>x.classList.remove('selected'));
        b.classList.add('selected');
      });
    }
    wrap.appendChild(b);
  });
  if(players.some(p=>p.color === selectedPaletteColor)){
    const free = PALETTE.find(c => !players.some(p=>p.color===c));
    if(free) selectedPaletteColor = free;
  }
}

function renderPlayersArea(){
  const area = el('playersArea'); area.innerHTML='';
  if(players.length === 0){ area.innerHTML = '<div class="small muted">Keine Spieler</div>'; return; }
  players.forEach((p,i)=>{
    const div = document.createElement('div'); div.className='row'; div.style.marginTop='6px';
    div.innerHTML = `<span class="player-swatch" style="background:${p.color}"></span>
      <div style="flex:1;color:black">${i+1}. <strong>${p.name}</strong> <span style="color:#888">(${p.status})</span></div>
      <div><button data-i="${i}" class="removeBtn">Entf.</button></div>`;
    area.appendChild(div);
  });
  document.querySelectorAll('.removeBtn').forEach(b=>b.addEventListener('click', e=>{
    const i = +e.currentTarget.dataset.i;
    players.splice(i,1);
    renderPlayersArea();
    renderPalette();
  }));
}

el('addPlayer').addEventListener('click', ()=>{
  const name = el('playerName').value.trim();
  if(!name) return;
  if(players.find(p=>p.name === name)){ alert('Name bereits vorhanden'); return; }
  if(players.some(p=>p.color === selectedPaletteColor)){ alert('Diese Farbe ist bereits vergeben. Wähle eine andere.'); return; }
  players.push({name, color: selectedPaletteColor, status: 'pending'});
  el('playerName').value = '';
  renderPlayersArea();
  renderPalette();
});

// --------------- Spielstart / Runde -----------------
el('startGame').addEventListener('click', async ()=>{
  if(players.length < 2){ alert('Mindestens 2 Spieler erforderlich'); return; }
  await loadCategoriesCSV();
  el('setupCard').style.display='none';
  el('gameCard').style.display='block';
  masterIndex = Math.floor(Math.random() * players.length);
  startRound();
});

function startRound(){
  confirmedGuesses = {};
  currentPicker = null; tempAngle = null;
  players.forEach(p => p.status = 'pending');
  players[masterIndex].status = 'master';
  targetAngle = Math.floor(Math.random() * (178 - 2 + 1)) + 2; // 2..178
  el('categoryText').textContent = categories[Math.floor(Math.random()*categories.length)];
  el('roundInfo').textContent = `Spielmacher: ${players[masterIndex].name}`;
  el('masterName').textContent = players[masterIndex].name;
  el('masterArea').style.display='block';
  el('guessArea').style.display='none';
  el('resultsArea').style.display='none';
  el('masterHint').style.display='none';
  el('showTargetBtn').style.display='inline-block';
  el('hideTargetBtn').style.display='none';
  renderMaster(false);
  renderGuess();
  renderPlayerList();
}

// --------------- Canvas Setup & Metrics -----------------
function setupCanvases(){
  canvasMaster = el('canvasMaster'); canvasGuess = el('canvasGuess');
  mctx = canvasMaster.getContext('2d'); gctx = canvasGuess.getContext('2d');
  function resize(c,ctx,h=340){
    const dpi = window.devicePixelRatio || 1;
    const parent = c.parentElement;
    const w = Math.max(320, parent.clientWidth - 12);
    c.style.width = w + 'px';
    c.style.height = h + 'px';
    c.width = Math.floor(w * dpi);
    c.height = Math.floor(h * dpi);
    ctx.setTransform(dpi,0,0,dpi,0,0);
  }
  resize(canvasMaster,mctx,340);
  resize(canvasGuess,gctx,340);
  window.addEventListener('resize', ()=>{ resize(canvasMaster,mctx,340); resize(canvasGuess,gctx,340); renderMaster(false); renderGuess(); });
}
function metrics(ctx){
  const dpi = window.devicePixelRatio || 1;
  const w = ctx.canvas.width / dpi;
  const h = ctx.canvas.height / dpi;
  const cx = w / 2;
  // Halbkreis insgesamt größer: cy näher an top (kleinerer subtrahend) und r größer
  const cy = h - 12; // etwas kleinerer Rand -> Halbkreis steigt etwas
  const r = Math.min(w/2 - 8, h - 18); // deutlich größerer Radius
  return {w,h,cx,cy,r};
}

// --------------- Zeichnen -----------------
function drawBase(ctx){
  const m = metrics(ctx);
  ctx.clearRect(0,0,ctx.canvas.width/(window.devicePixelRatio||1), ctx.canvas.height/(window.devicePixelRatio||1));
  // semicircle from PI to 2PI (left -> top -> right)
  ctx.beginPath(); ctx.moveTo(m.cx - m.r, m.cy); ctx.arc(m.cx, m.cy, m.r, Math.PI, 2*Math.PI, false); ctx.closePath();
  ctx.fillStyle = '#fff'; ctx.fill();
  ctx.lineWidth = 1.6; ctx.strokeStyle = '#c7cfe0'; ctx.stroke();
}

// Alle Keile jetzt gleich groß (halfDeg unified)
function drawTargetSegmentsInside(ctx, centerAngle){
  const m = metrics(ctx);
  const outer = m.r - 6;
  const inner = Math.max(m.r - 96, m.r * 0.45);
  const halfDeg = 2.2; // größerer Wert -> alle Keile gleich groß (entspricht gewünschter Größe)

  function wedge(angleDeg, halfDegLocal, color, label){
    const centerRad = Math.PI + (angleDeg * Math.PI/180);
    const halfRad = halfDegLocal * Math.PI/180;
    const start = centerRad - halfRad;
    const end   = centerRad + halfRad;
    ctx.beginPath();
    ctx.moveTo(m.cx + inner*Math.cos(start), m.cy + inner*Math.sin(start));
    ctx.lineTo(m.cx + outer*Math.cos(start), m.cy + outer*Math.sin(start));
    ctx.arc(m.cx, m.cy, outer, start, end, false);
    ctx.lineTo(m.cx + inner*Math.cos(end), m.cy + inner*Math.sin(end));
    ctx.arc(m.cx, m.cy, inner, end, start, true);
    ctx.closePath();
    ctx.fillStyle = color; ctx.globalAlpha = 0.95; ctx.fill(); ctx.globalAlpha = 1;
    ctx.lineWidth = 0.8; ctx.strokeStyle = 'rgba(0,0,0,0.06)'; ctx.stroke();
    const mid = centerRad;
    const lx = m.cx + (inner + (outer-inner)/2) * Math.cos(mid);
    const ly = m.cy + (inner + (outer-inner)/2) * Math.sin(mid);
    ctx.fillStyle = '#111'; ctx.font = 'bold 12px sans-serif'; ctx.fillText(label, lx-6, ly+4);
  }

  wedge(centerAngle+2, halfDeg, '#16a34a', '3');
  wedge(centerAngle-2, halfDeg, '#16a34a', '3');
  wedge(centerAngle+1, halfDeg, '#f59e0b', '4');
  wedge(centerAngle-1, halfDeg, '#f59e0b', '4');
  wedge(centerAngle,   halfDeg, '#ef4444', '5');
}

// draw player arrow
function drawArrow(ctx, angle, color, label, highlighted=false){
  const m = metrics(ctx);
  const ang = Math.PI + (angle * Math.PI/180);
  const tipX = m.cx + (m.r-6)*Math.cos(ang), tipY = m.cy + (m.r-6)*Math.sin(ang);
  const baseR = m.r - 48;
  const baseX = m.cx + baseR*Math.cos(ang), baseY = m.cy + baseR*Math.sin(ang);
  const ortX = Math.cos(ang - Math.PI/2), ortY = Math.sin(ang - Math.PI/2);
  const half = highlighted ? 12 : 8;
  const p1=[tipX,tipY], p2=[baseX+ortX*half, baseY+ortY*half], p3=[baseX-ortX*half, baseY-ortY*half];
  ctx.beginPath(); ctx.moveTo(p1[0],p1[1]); ctx.lineTo(p2[0],p2[1]); ctx.lineTo(p3[0],p3[1]); ctx.closePath();
  ctx.fillStyle = rgba(color,1); ctx.fill();
  if(highlighted){ ctx.lineWidth=2; ctx.strokeStyle='rgba(0,0,0,0.12)'; ctx.stroke(); }
  const lx = m.cx + (m.r-66)*Math.cos(ang), ly = m.cy + (m.r-66)*Math.sin(ang);
  ctx.fillStyle = '#000'; ctx.font = highlighted ? 'bold 13px sans-serif' : '12px sans-serif';
  ctx.fillText(label, lx + 10, ly + 4);
}

// --------------- Render Master & Guess -----------------
let masterShow = false;
function renderMaster(force=false){
  drawBase(mctx);
  if(force || masterShow) drawTargetSegmentsInside(mctx, targetAngle);
  if(!force && !masterShow){
    const mm = metrics(mctx);
    mctx.fillStyle='rgba(0,0,0,0.03)';
    mctx.fillRect(0,0,mctx.canvas.width/(window.devicePixelRatio||1), mctx.canvas.height/(window.devicePixelRatio||1));
    mctx.fillStyle='#444'; mctx.font='14px sans-serif';
    mctx.fillText('Ziel ist versteckt. Nur Spielmacher darf es sehen.', 12, 20);
  }
}

// während Guess-Phase: bestätigte Pfeile **nicht** anzeigen
function renderGuess(){
  drawBase(gctx);
  if(currentPicker && tempAngle !== null){
    const p = players.find(pp=>pp.name===currentPicker);
    if(p) drawArrow(gctx, tempAngle, p.color, p.name, true);
  }
}

// --------------- Player Liste -----------------
function renderPlayerList(){
  const cont = el('playerList'); cont.innerHTML='';
  players.forEach(p=>{
    if(p.status === 'master') return;
    const btn = document.createElement('button');
    btn.textContent = p.name;
    btn.style.color = 'black';
    btn.classList.remove('done','current');
    if(p.status === 'done') btn.classList.add('done');
    if(p.status === 'current') btn.classList.add('current');
    const sw = document.createElement('span'); sw.className='player-swatch'; sw.style.background = p.color;
    if(p.status === 'done') sw.style.opacity = 0.35;
    btn.prepend(sw);
    btn.addEventListener('click', ()=>{
      if(p.status === 'done'){ alert('Dieser Spieler hat bereits bestätigt.'); return; }
      players.forEach(pp=>{ if(pp.status === 'current') pp.status='pending'; });
      p.status = 'current'; currentPicker = p.name; tempAngle = null;
      el('selectNotice').textContent = `Markiere jetzt: ${p.name}`;
      el('confirmBtn').style.display = 'inline-block';
      renderPlayerList();
      renderGuess();
    });
    cont.appendChild(btn);
  });
}

// --------------- Pointer -> Winkel (robust) ---------------
function canvasToAngle(clientX, clientY, ctx){
  const rect = ctx.canvas.getBoundingClientRect();
  const x = clientX - rect.left;
  const y = clientY - rect.top;
  const m = metrics(ctx);

  if(y > m.cy + 36) return null;

  let nx = (x - m.cx) / m.r;
  nx = Math.max(-1, Math.min(1, nx));
  const arcRad = Math.acos(nx);
  let angleB = 180 - (arcRad * 180 / Math.PI);

  const dxA = x - m.cx;
  const dyA = m.cy - y;
  let phi = Math.atan2(dyA, dxA);
  let phiDeg = phi * 180 / Math.PI;
  let angleA = 180 - phiDeg;
  angleA = (angleA + 360) % 360;
  if(angleA < 0 || angleA > 180) angleA = null;

  function projDist(angleDeg){
    if(angleDeg === null) return 1e9;
    const ang = Math.PI + (angleDeg * Math.PI/180);
    const px = m.cx + m.r * Math.cos(ang);
    const py = m.cy + m.r * Math.sin(ang);
    return Math.hypot(px - x, py - y);
  }

  const dA = projDist(angleA);
  const dB = projDist(angleB);
  const chosen = (dA <= dB) ? angleA : angleB;

  const dx = x - m.cx, dy = y - m.cy;
  const distToCenter = Math.hypot(dx, dy);
  if(distToCenter > m.r + 48) return null;
  if(distToCenter < m.r * 0.2) return null;

  return (chosen === null) ? null : Math.round(chosen);
}

// --------------- Drag / Auswahl Bindings -----------------
function bindGuessDrag(){
  let dragging = false;
  canvasGuess.addEventListener('pointerdown', e=>{
    if(!currentPicker) return;
    dragging = true; canvasGuess.setPointerCapture(e.pointerId);
    const a = canvasToAngle(e.clientX, e.clientY, gctx);
    if(a === null){ el('selectNotice').textContent = 'Nur entlang des Halbkreises wählen.'; setTimeout(()=>el('selectNotice').textContent='',900); return; }
    tempAngle = a; renderGuess();
  });
  canvasGuess.addEventListener('pointermove', e=>{
    if(!dragging) return;
    const a = canvasToAngle(e.clientX, e.clientY, gctx);
    if(a === null) return;
    tempAngle = a; renderGuess();
  });
  canvasGuess.addEventListener('pointerup', e=>{
    dragging = false; canvasGuess.releasePointerCapture(e.pointerId);
  });
}

// --------------- Confirm / Cancel -----------------
el('confirmBtn').addEventListener('click', ()=>{
  if(!currentPicker){ alert('Wähle zuerst deinen Namen'); return; }
  if(tempAngle === null){ alert('Ziehe zuerst den Pfeil'); return; }
  confirmedGuesses[currentPicker] = tempAngle;
  const p = players.find(pp=>pp.name === currentPicker); if(p) p.status = 'done';
  currentPicker = null; tempAngle = null;
  el('confirmBtn').style.display = 'none';
  el('selectNotice').textContent = 'Markierung gespeichert.'; setTimeout(()=>el('selectNotice').textContent = '', 900);
  renderPlayerList();
  renderGuess();

  const remaining = players.filter(pp=>pp.status !== 'done' && pp.status !== 'master');
  if(remaining.length === 0){
    el('guessArea').style.display='none';
    el('resultsArea').style.display='block';
    el('postRoundNotice').style.display='block';
    el('postRoundNotice').textContent = 'Alle Spieler haben gewählt. Bitte gebe das Handy an den Spielmacher zurück.';
    const ctrl = el('postRoundControls'); ctrl.innerHTML = '';
    const btn = document.createElement('button');
    btn.textContent = 'Ergebnis anzeigen (Spielmacher)';
    btn.addEventListener('click', ()=>{
      // Use revealCanvasWrap size (visible) instead of hidden canvasGuess parent
      renderReveal(true);
      renderScores();
      btn.disabled = true;
      el('postRoundNotice').style.display = 'none';
      // scroll into view for convenience
      el('revealCanvasWrap').scrollIntoView({behavior:'smooth', block:'center'});
    });
    ctrl.appendChild(btn);
  }
});

el('cancelBtn').addEventListener('click', ()=>{
  if(currentPicker){
    const p = players.find(pp=>pp.name === currentPicker); if(p) p.status='pending';
    currentPicker = null; tempAngle = null;
    el('confirmBtn').style.display = 'none'; el('selectNotice').textContent = '';
    renderPlayerList(); renderGuess();
  }
});

// --------------- Master controls -----------------
el('showTargetBtn').addEventListener('click', ()=>{
  masterShow = true; el('masterHint').style.display='block';
  el('showTargetBtn').style.display='none'; el('hideTargetBtn').style.display='inline-block';
  renderMaster(true);
});
el('hideTargetBtn').addEventListener('click', ()=>{
  masterShow = false; el('masterHint').style.display='none';
  el('hideTargetBtn').style.display='none'; el('showTargetBtn').style.display='inline-block';
  renderMaster(false);
});
el('masterDoneBtn').addEventListener('click', ()=>{
  el('masterArea').style.display='none';
  el('guessArea').style.display='block';
  renderGuess();
  renderPlayerList();
  bindGuessDrag();
});

// --------------- Reveal & Score -----------------
function renderReveal(showTarget){
  const wrap = el('revealCanvasWrap');
  const w = wrap.clientWidth || Math.max(320, document.documentElement.clientWidth - 24);
  const h = 260;
  const c = document.createElement('canvas'); const dpi = window.devicePixelRatio || 1;
  c.width = Math.floor(w * dpi); c.height = Math.floor(h * dpi);
  c.style.width = w + 'px'; c.style.height = h + 'px';
  const ctx = c.getContext('2d'); ctx.setTransform(dpi,0,0,dpi,0,0);
  drawBase(ctx);
  // draw all confirmed player arrows
  Object.entries(confirmedGuesses).forEach(([name,ang])=>{
    const p = players.find(pp=>pp.name === name);
    if(p) drawArrow(ctx, ang, p.color, name, false);
  });
  if(showTarget) drawTargetSegmentsInside(ctx, targetAngle);
  wrap.innerHTML = '';
  wrap.appendChild(c);
}

function renderScores(){
  const scores = {};
  players.forEach(p=>scores[p.name] = 0);
  Object.entries(confirmedGuesses).forEach(([name,ang])=>{
    const d = Math.abs(ang - targetAngle);
    const pts = (d === 0) ? 5 : (d === 1) ? 4 : (d === 2) ? 3 : 0;
    scores[name] += pts;
  });
  const node = el('scores'); node.innerHTML = '';
  const arr = Object.entries(scores).filter(([n]) => n !== players[masterIndex].name).sort((a,b)=>b[1]-a[1]);
  arr.forEach(([name,pts])=>{
    const p = players.find(pp=>pp.name === name);
    const sw = `<span style="display:inline-block;width:12px;height:12px;background:${p.color};border-radius:3px;margin-right:8px"></span>`;
    const div = document.createElement('div'); div.className = 'leader';
    div.innerHTML = `<div>${sw}${name}</div><div>${pts} P</div>`;
    node.appendChild(div);
  });
  const md = document.createElement('div'); md.className='small muted';
  md.textContent = 'Spielmacher: ' + players[masterIndex].name;
  node.appendChild(md);
}

// --------------- Neue Runde -----------------
el('newRoundBtn').addEventListener('click', ()=>{
  masterIndex = (masterIndex + 1) % players.length;
  startRound();
});

// --------------- Init -----------------
function init(){
  renderPalette();
  setupCanvases();
  renderPlayersArea();
}
init();

</script>
</body>
</html>
